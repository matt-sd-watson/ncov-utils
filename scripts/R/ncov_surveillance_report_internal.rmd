---
title: "SARS-CoV-2 Genomics"
subtitle: "Internal Report" 
date: "Updated:  `r format(Sys.time(), '%B %d, %Y')`<div style=\"height: 40px;\"></div>"
# "Period: `r format(Sys.time() - 7*24*3600, '%B %d, %Y')` to `r format(Sys.time(), '%B %d, %Y')`"
mainfont: Arial
fontsize: 11
link-citations: yes
urlcolor:  #5E3B76
linkcolor: #5E3B76
citecolor: #5E3B76
output:
  html_document:
    toc: yes
    toc_float: no
    toc_depth: 4
    number_sections: no
    theme: readable
  pdf_document:
    toc: yes
    toc_depth: '4'
    includes:
      in_header: header.tex
toc-title: "Contents"
---

 <style type="text/css">
 .title {
  font-size: 38px;
  color: #4A4A4A;
  margin-top: 84px;
}
 .subtitle {
  font-size: 24px;
  color: #4A4A4A;
}
.author {  
  font-size: 24px;
  color: #4A4A4A;
}
.date {  
  font-size: 14px;
  color: #4A4A4A;
}
  h1 { /* Header 1 */
  font-size: 20pt;
  color: #4A4A4A;
}
h2 { /* Header 2 */
    font-size: 14pt;
  color: #4A4A4A;
}
h3 { /* Header 2 */
    font-size: 12pt;
  color: #616161;
}
body { /* Normal */
    font-size: 12pt;
    font-family: "Arial"; 
  color: black;
}
td { /* Table */
    font-size: 12pt;
    font-family: "Arial"; 
    color: black;
}
table th {
     background-color: #595959;
    /* sets table header cell background colour */
    }
TOC a {
 color: #5E3B76;
     font-size: 11pt;
 }
a {
  color: #5E3B76;
}

.figure {
   margin-top: 1px;
   margin-bottom: 1px;
}

</style>


```{r logo, echo=FALSE, out.width = "10%"}
htmltools::img(src = knitr::image_uri(file.path("./2_Input/PHO_Signature_en.svg")),
#htmltools::img(src = knitr::image_uri(file.path("./2_Input/PHO_Signature.png")),               
              alt = 'logo',
              style = 'position:absolute; top:20px; left:15px; padding:5px;')
```


\
\
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(data.table)
library(ggrepel)
library(lubridate)
library(viridis)
library(gridExtra)
# library(wesanderson)
library(RColorBrewer)
library(directlabels)
# library(argparse)
library(ggpubr)
library(gridExtra)
library(waffle)
library(magrittr)
library(hrbrthemes)
library(plotly)
library(knitr)
library(tidyverse)
options(dplyr.summarise.inform = FALSE)
library(lubridate)
# install.packages("https://cran.r-project.org/src/contrib/Archive/EpiWeek/EpiWeek_1.1.tar.gz",
#                 repos = NULL, type="source")
library(EpiWeek)
library(paletteer)
library(unikn)
library(lemon)
library(treemapify)
library(colorspace)  # install via: install.packages("colorspace", repos = "http://R-Forge.R-project.org")
library(scales)
# library(ggtree)
library(ape)
library(DT)
library(htmlwidgets)
library(gtable)
library(kableExtra)
library(reactable)
library(grid)
library(lemon)

```

_________________


# Background

<p>Information is current as of **`r format(Sys.Date(), "%B %e, %Y")`**. This report summarizes analysis of SARS-CoV-2 samples with whole genome sequencing at Public Health Ontario (PHO) Laboratory. Each report provides an initial count of all sequenced samples and the remaining analyses focus on 2021 samples.</p>

<p>PHO Laboratory performs whole genome sequencing (WGS) on a selection of SARS-CoV-2 samples submitted for primary diagnostic testing or specific PCR testing for Variants of Concern (VOC). Therefore, it is important to note that the numbers reported here do not represent all SARS-CoV-2 in Ontario. Furthermore, there is currently a bias towards sequencing of samples for which mutations present in VOCs have been detected.</p>

```{r VOC, VOI and mutations lists, include = FALSE}

# ---->>>> List of VOCs <<<<----
voc.list <- c("B.1.1.7", "B.1.351", "P.1", "B.1.617.2")  # Add B.1.1.7 with E484K ?

# ---->>>> List of VOIs <<<<----
voi.list <- c("P.2", "P.3", "A.23.1", "A.23.1 with E484K", "B.1.2 with E484K",
              "R.1", "B.1.1.318", "B.1.427", "B.1.429", "B.1.525", "B.1.526", "B.1.526.1", 
              "B.1.526.2", "B.1.526.3",  "B.1.617.1")


# ---->>>> List of N501Y <<<<----
n501y.lin.list <- c("P.1.2", "XA", "P.3", " A.27", "B.1.1.7", 
                    "AP.1", "P.1", "P.1.1", "B.1.623", "B.1.621", "B.1.351.3", 
                    "B.1.351", "B.1.351.2", "B.1.604", "B.1.1.136")

# ---->>>> List of E484K <<<<----
e484k.lin.list <- c("A.23.1 with E484K", "B.1.2 with E484K", "B.1.1.7 with E484K",
                    "P.1.2", "P.3" , "N.10", "B.1.1.345","R.1","P.2" , "AV.1",
                    "B.1.618", "B.1.177.88", "R.2", "B.1.1.318", "B.1.525",
                    "B.1.619", "P.1.1" ,"P.1", "N.9", "B.1.1.523", "B.1.620",
                    "B.1.621", "B.1.351.3", "B.1.351","B.1.351.2","B.1.526" ,"AT.1", "B.1.243.1")
                    
# ---->>>> List of E484Q <<<<----
e484q.lin.list <- c("B.1.617", "B.1.617.1", "B.1.617.3")

```


```{r data cleaning, include = FALSE}

#---- Import dataset ----
meta.list <- list.files("./2_Input/", pattern = "export*|qc50*|qc90*")
meta.data <- read.csv(paste("./2_Input/", meta.list, sep=""), header = TRUE, na.strings=c("","NA"), stringsAsFactors=FALSE)


# Subset to include only processed results
# Filter to remove records without a login date
# Ensure distinct records
meta.df <- meta.data %>%
             filter(!is.na(Login_Date)) %>%
             filter(Processed_results == "Y") %>%
             filter(Exclude_from_analysis == "N" | is.na(Exclude_from_analysis)) %>%
             distinct()
  


# ---- Clean up and Derive variables ----
meta.df.1 <- meta.df %>%
                mutate(Login.Date = as.Date(Login_Date, format =  "%d%b%Y")) %>%
                mutate(epi.wk.login = ifelse(is.na(Login.Date), NA,
                                             paste(epiyear(Login.Date), 
                                             sprintf( "%02d", epiweek(Login.Date)), sep = "-"))) %>%
                mutate(lineage.all = ifelse(lineage_all == "B.1.2" & E484K == "Detected", "B.1.2 with E484K",
                                     ifelse(lineage_all == "B.1.1.7" & E484K == "Detected", "B.1.1.7 with E484K",
                             	       ifelse(lineage_all == "A.23.1" & E484K == "Detected", 
                             	             "A.23.1 with E484K", lineage_all)))) %>%
                mutate(lineage.all.cat = ifelse(lineage.all %in% voc.list, "VOC",
                                         ifelse(lineage.all %in% voi.list, "VOI", "Other"))) %>%
                mutate(lin.parent.grp = gsub("\\..*","",lineage.all)) %>%
  
                mutate(upload.date.lineage.plate = 
                       as.Date(upload_date_lineage_plate, format =  "%m/%d/%Y")) %>%  
                mutate(epi.wk.compl = epiweek(upload.date.lineage.plate)) %>%
                mutate(Processed_results_date = as.Date(Processed_results_date, format =  "%m/%d/%Y")) 



# ---- Define previous epi week dates ----
prev.epiwk <- epiweekToDate(as.numeric(format(Sys.Date(), "%Y")), epiweek(Sys.Date())-1, firstday = "Sunday")

prev.epiwk.start <- as.Date(format(prev.epiwk$d0, "%B %e, %Y"), format = "%B %e, %Y")
prev.epiwk.start.txt <- format(prev.epiwk$d0, "%B %e, %Y")
prev.epiwk.end <- as.Date(format(prev.epiwk$d1, "%B %e, %Y"), format = "%B %e, %Y")
prev.epiwk.end.txt <- format(prev.epiwk$d1, "%B %e, %Y")


# ---- Define epi week dates: 3 weeks prior ----
prev3.epiwk <- epiweekToDate(as.numeric(format(Sys.Date(), "%Y")), epiweek(Sys.Date())-3, firstday = "Sunday")

prev3.epiwk.start <- as.Date(format(prev3.epiwk$d0, "%B %e, %Y"), format = "%B %e, %Y")
prev3.epiwk.start.txt <- format(prev3.epiwk$d0, "%B %e, %Y")
prev3.epiwk.end <- as.Date(format(prev3.epiwk$d1, "%B %e, %Y"), format = "%B %e, %Y")
prev3.epiwk.end.txt <- format(prev3.epiwk$d1, "%B %e, %Y")


# ---- Filter to exclude samples added after prev. epi week ----
meta.df.2 <- meta.df.1 %>% 
                filter(is.na(Processed_results_date) |
                (!is.na(Processed_results_date) &
                (Processed_results_date <= as.Date(prev.epiwk.end))))


# ---- Filter to include only 2021 ----
meta.df.2021 <- meta.df.2 %>% 
                    filter(Login.Date >= "2021-01-01")
 
```

```{r nextclade import, include = FALSE}
# read in the Nextclade data that has the mutation profiles
# make sure that the nextclade data is taken from the qc50 or qc90 sequences (whichever is used here) and not all

nextclade_loc <- list.files("./2_Input/", pattern = "nextclade*")
nextclade_data <-read.table(paste("./2_Input/", nextclade_loc, sep=""), 
                            header = T, sep = '\t', fill = TRUE, quote = "") 

```

```{r data prep PHUs, include = FALSE}

# ----+ Prepare date for PHU pie charts +----
total_lin_counts <- subset(meta.df.2021, lineage.all %in% voc.list) %>%
                      arrange(Login.Date) %>%
                      group_by(lineage.all) %>% 
                      dplyr::summarise(total = n())

subset_lineages <- subset(meta.df.2021, lineage.all %in% voc.list & lineage.all != "None") %>%
                      arrange(Login.Date) %>%
                      group_by(lineage.all, HEALTH_UNIT_REPORTABLE) %>% 
                      dplyr::summarise(lin_counts = n())

merged <- merge(subset_lineages, total_lin_counts, by.x = "lineage.all", by.y = "lineage.all")
merged$percent <- round(100*(merged$lin_counts/merged$total), 2)
merged$new_name <- paste(merged$lineage.all, " ", "(", merged$total, ")", sep="")
merged$region_counts <- paste(merged$HEALTH_UNIT_REPORTABLE, " ", "(", merged$lin_counts, ")", sep="")

labels_over_2.5 <- subset(merged, percent >= 2.5)

for (i in unique(merged$lineage.all)) {
  subset <- subset(merged, lineage.all == i)
  title_name <- unique(subset$new_name)
  plot_name <- paste("pie_chart", i, sep="_")
  plot <- plot_ly(subset, labels = ~ region_counts, values = ~percent, type = 'pie',
                  textposition = 'inside',textinfo = 'label+percent',
                  textfont = list(color= c("white"), size = 15)) %>%
    layout(title = title_name,
           xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
           yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
           showlegend = T, colorway = c('rgba(114,147,203,1)',  'rgba(128,133,133,1)',
                                        'rgba(211,94,96,1)',
                                        'rgba(144,103,167,1)', 'rgba(171,104,87,1)'),
           showlegend = T)
  
  # on render function allows for clicking on legend entries to isolate in pie chart
  plot_animated <- ggplotly(plot) %>% onRender("function(el,x){el.on('plotly_legendclick', function(){ x.returnValue = false; })}")
  assign(plot_name, plot_animated)
}

```


```{r, echo = FALSE, include=FALSE}

# ----+ Total Number of Genomes +----

# Change from last reported (assume reporting every Wednesday)
time.cat.table <- meta.df.2 %>%
                   dplyr:: mutate(time.cat.new = ifelse(!is.na(Processed_results_date) &
                                             (Processed_results_date >= prev.epiwk$d0 & 
                                              Processed_results_date <= prev.epiwk$d1), 
                                             "Change in genomes",  "Old")) %>%
                    group_by(time.cat.new, .drop=FALSE) %>%
                    summarise(n = n()) %>%
                    spread(as.numeric(time.cat.new), as.numeric(n)) %>%
                    mutate(Total = sum(`Change in genomes`, Old)) %>%
                    mutate_each(list(~format(., nsmall=1, big.mark=",")))



# Recent genomes (last 3 weeks)
time.cat.table.3wks <- meta.df.2 %>%
                        mutate(time.cat = ifelse(Login.Date >= prev3.epiwk$d0 & 
                                                 Login.Date <= prev3.epiwk$d1, 
                                                 "Recent genomes", "Older genomes")) %>%
                        mutate(time.cat = factor(time.cat, 
                                          levels = c("Recent genomes", "Older genomes"))) %>%
                        group_by(time.cat, .drop=FALSE) %>%
                        summarise(n = format(n(), nsmall=1, big.mark=",")) %>%
                        spread(time.cat, n)



# ----+ Total number of lineages by Year +----
num.lineages.yr <- meta.df.2 %>%  
                    filter(lineage.all != "None" & 
                             !is.na(lineage.all)) %>%   ##Why passes QC and doesn't have lineage?? Check!
                    mutate(login.yr = format(Login.Date, "%Y")) %>%
                    distinct(lineage.all, login.yr) %>%
                    group_by(login.yr, lineage.all) %>%
                    dplyr::summarise(n = n()) %>%
                    ungroup() %>%
                    group_by(login.yr) %>%
                    summarise(n.lin.yr = n()) %>%
                    spread(login.yr, n.lin.yr)



num_lineages <- data.frame(Category = paste("Number of unique Pango lineages", sep=""),
                                           # "(January 1, 2021 - ", 
                                          #  format(Sys.time(), "%B %d, %Y"), ")", sep=""),
                           Number = length(unique(meta.df.2021$lineage.all)))


# number of palettes needed
n.lin.parent <- meta.df.2021 %>%
                filter(lineage.all != "None" & !is.na(lineage.all)) %>%
                distinct(lin.parent.grp) %>%
                summarise(n = n())

n.lin.grp <- meta.df.2021 %>% 
              filter(lineage.all != "None" & !is.na(lineage.all)) %>%
              group_by(lin.parent.grp, lineage.all) %>%
              dplyr::summarise(n = n()) %>%
              ungroup()


# Use 9 palettes from the colorspace package, one for each parent lineage  #### Need to think about this in case more parent lineages than 9
palette <- c( "Purp",  "Greens", "Purples","Viridis", "Mint", "Teal", "PinkYl","PuRd","Burg", "RedOr")

n.lin.grp.cols <- n.lin.grp %>% 
                    distinct(lin.parent.grp) %>%
                    bind_cols(palette = palette) %>%
                    right_join(., n.lin.grp, by = "lin.parent.grp")


# Lineages will have a gradient that resets between parent lineages
meta.df.2021.col <- n.lin.grp.cols %>%
                        arrange(lin.parent.grp) %>% 
                        group_by(lin.parent.grp) %>%
                        mutate(colour = colorspace::sequential_hcl(length(lineage.all)+1, 
                               palette = palette)[seq_along(lineage.all)])

# Generate plot
pl.lin <- ggplot(meta.df.2021.col, aes(area = n, label = lineage.all, 
                                      fill = colour, subgroup = lin.parent.grp)) + 
            geom_treemap() + 
            geom_treemap_subgroup_border(color = "white") +
            geom_treemap_text(colour = "white", place = "topleft", reflow = T, min.size = 5) +
            theme(legend.position="none") + 
            scale_fill_identity()


# Lineage statistics for table
n.lin.grp <- meta.df.2021 %>% 
              filter(!is.na(lineage.all) & 
                       lineage.all != "None") %>%   ##Why passes QC and doesn't have lineage?? Check!
              group_by(lineage.all) %>%
              dplyr::summarise(n = n()) %>%
              mutate(rel.freq = round(100*(n/sum(n)),2)) %>%
              ungroup() %>%
              left_join(., dplyr::select(meta.df.2021, lineage.all, 
                                         lineage.all.cat) %>% 
                        distinct(), by = "lineage.all") %>%
              mutate(lineage.all.cat = ifelse(lineage.all.cat == "Other", "", lineage.all.cat)) %>%
              select(`Pango Lineage` = lineage.all, `Number of Genomes` = n, 
                     `Percentage` =rel.freq, Category = lineage.all.cat) %>%
              arrange(desc(`Number of Genomes`))


```
\

_________________

\


# Sequencing Summary

<p>The number of genome sequences are summarized below and categorized by the **Total genomes** as of `r prev.epiwk.end.txt`, the **Change in genomes**, which represents the number of samples sequenced since the last report, and **Recent genomes** which represents the number of genomes sequenced with a sample login date in the previous three weeks
(`r prev3.epiwk.start.txt` - `r prev.epiwk.end.txt`).</p><br>

```{r Total Genomes boxes, fig.width = 8, fig.height = 2.25, echo=F, warning=F, message=F, fig.keep = 'last'}

ggplot(data.frame(Total = c("A", "A", "A"), Recent = c(0, 1, 2)),
       aes(y = Total, x = Recent)) +
  geom_tile(color = "white", fill = "#F7F7F7", size = 5) +  
  
  annotate(geom="text", x=0, y=1.25, label="Change in genomes",
           color="#4B8184", size = 6) +
  annotate(geom="text", x=0, y=1, label=time.cat.table$`Change in genomes`,
           color="#4B8184", size = 12, fontface = 'bold') +
  
  annotate(geom="text", x=0, y=0.65, label="Since last report",
           color="#4B8184", size = 4) +
  
  annotate(geom="text", x=1, y=1.25, label="Recent genomes",
           color="#4B8184", size = 6) +
  annotate(geom="text", x=1, y=1, label=time.cat.table.3wks$`Recent genomes`,
           color="#4B8184", size = 12, fontface = 'bold') +
  
    annotate(geom="text", x=1, y=0.65, label="Previous 3 weeks",
           color="#4B8184", size = 4) +
  
  annotate(geom="text", x=2, y=1.25, label="Total genomes",
           color="#4B8184", size = 6) +
  annotate(geom="text", x=2, y=1, label=time.cat.table$Total,
           color="#4B8184", size = 12, fontface = 'bold') +
  theme_void() +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_discrete(expand = c(0,0)) 


```

\
\


## Number of Genomes by Sample Login Date

<br>

```{r data prep, echo = FALSE, include=FALSE}

# ----+ Prepare data for bar plots, incl ALL weeks, autoscale +----

# Create a dataframe of 2020 only
meta.df.prev <- meta.df.2 %>%
                  filter(Login.Date <= "2020-12-31") %>%
                  distinct(Login.Date)
  
# Generate a list of epi weeks to-date 
epiwk.list.2020 <- paste("2020", sprintf("%02d", seq(min(epiweek(meta.df.prev$Login.Date)),
                                                     max(epiweek(meta.df.prev$Login.Date)), by = 1)), sep = "-")
epiwk.list.2021 <- paste(format(Sys.Date(), "%Y"), sprintf("%02d", seq(1, epiweek(Sys.Date())-1, by = 1)), sep = "-")
epiwk.list.all <- c(epiwk.list.2020, epiwk.list.2021)
epiwk.list.all.df <- data.frame(epiwk.list.all)

                
# identify most recent epiweek
end.epi.wk <- max(epiwk.list.all)

# Create a dataframe that completes all weeks (including those that have zero genomes)
meta.df.all.wks <- meta.df.2 %>% 
                    right_join(., epiwk.list.all.df, by = c("epi.wk.login" = "epiwk.list.all")) %>% 
                    select(WGS_Id, epi.wk.login, lineage.all, lineage.all.cat)

# Make a preliminary plot to extract autoscales
pl.n <- meta.df.all.wks %>% 
            ggplot() +
            geom_bar(aes(x=epi.wk.login)) +
            scale_y_continuous("Number of genomes", expand = c(0,10))


# Extract automatic scale
y.labs <- ggplot_build(pl.n)$layout$panel_params[[1]]$y$get_labels()
y.labs.intv <- y.labs %>%
                as.data.frame() %>%
                filter(!is.na(.)) %>%
                mutate(max.lab = max(as.numeric(.))) %>%
                mutate(intv=max.lab/(n()-1)) %>%
                distinct(intv) 
   
y.labs.scale <- y.labs %>%
                as.data.frame() %>%
                filter(!is.na(.)) %>%
                rename(intv = ".") %>%
                mutate(intv = as.numeric(intv)) %>%
                add_row(intv = y.labs.intv$intv + max(.$intv))%>%
                pull() 


```


```{r, echo=F, message=F, warning=F, fig.width=16, fig.height=8.5}

#---- Weekly Sequencing Summary Barplot ----

## create barplot of sequences, filtered to those with genome coverage >90%, epiweek login date in 2020 # Need to change this not include the completeness and just use database reported/processed
meta.df.all.wks %>% ggplot() +
                       geom_rect(aes(xmin = which(epiwk.list.all==end.epi.wk)-6.5,
                       xmax = which(epiwk.list.all==end.epi.wk)+0.5,
                       ymin=-Inf, ymax=Inf),
                       fill="grey90") + 
                       ggtitle("Subject to \nsequencing lag") +
                       # annotate("text", x = which(epiwk.list.all==end.epi.wk)-8.45, 
                       #                  y = Inf, 
                       #                  label = "Subject to \nsequencing lag",
                       #                  size = 5, vjust = 1.2, hjust = -.03, color = "black") +
                      theme(plot.tag.position = c(0.96, 0.9)) +
                      geom_bar(aes(x=epi.wk.login)) +
                      theme(axis.text.x = element_text(angle = 90, size = 16, vjust = 0.5),
                            axis.text.y = element_text(size = 16),
                            axis.title.x = element_text(size = 16, 
                                                        margin = margin(t = 20, r = 0, b = 0, l = 0)),
                            axis.title.y = element_text(size = 16),
                            plot.title = element_text(size = 14, hjust = 1),
                            plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
                            panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                            panel.background = element_blank(), axis.line = element_line(colour = "black"),
                            legend.position = c(0.87, 0.75),
                            legend.title = element_text(size = 16),
                            legend.text = element_text(size = 14)) +
                      labs(fill = "Category") + xlab("Epidemiological week") + ylab("Sample Counts") +
                      coord_capped_cart(left='both', bottom = 'both') +
                      scale_x_discrete("Epidemiological week") +
                      scale_y_continuous("Number of genomes", 
                                         expand = c(0,10), limits = c(0, max(y.labs.scale)),                   
                                         breaks = y.labs.scale, 
                                         labels = y.labs.scale)
                  


```
  
\
<p> </p>
_________________

<br>

# Pango Lineages

As part of PHOâ€™s bioinformatic processing, all genomic sequences are routinely analyzed using the pangolin tool (https://cov-lineages.org/index.html) and receive a Pango lineage designation. The dynamic Pango nomenclature system allows for the classification of SARS-CoV-2 genetic diversity. Reassignments of Pango lineages are expected to occur as more SARS-CoV-2 genome sequences become available, thus providing a more complete picture of SAS-CoV-2 evolution and more accurate lineage assignment.
\
\

<br>


## Number of Pango Lineages by Year
\

```{r, fig.width = 5.25, fig.height = 2.25, echo=F, warning=F, message=F, fig.keep = 'last'}

ggplot(data.frame(Total = c("A", "A"), Recent = c(0, 1)),
       aes(y = Total, x = Recent)) +
  geom_tile(color = "white", fill = "#F7F7F7", size = 5) +  
  annotate(geom="text", x=0, y=1.25, label="Unique Lineages",
           color="#4B8184", size = 6) +
  annotate(geom="text", x=0, y=1, label=num.lineages.yr$`2020`,
           color="#4B8184", size = 12, fontface = 'bold') +
  
  annotate(geom="text", x=0, y=0.65, label="Year, 2020",
           color="#4B8184", size = 4) +
  
  annotate(geom="text", x=1, y=1.25, label="Unique Lineages",
           color="#4B8184", size = 6) +
  annotate(geom="text", x=1, y=1, label=num.lineages.yr$`2021`,
           color="#4B8184", size = 12, fontface = 'bold') +
  annotate(geom="text", x=1, y=0.65, label="Year, 2021",
           color="#4B8184", size = 4) +
  theme_void() +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_discrete(expand = c(0,0)) 
```

\
\

<br>

## Visualization of Pango Lineage Frequencies

Pango lineages from sequenced samples (January 1, 2021 - `r prev.epiwk.end.txt`). The plot is divided into tiles, each of which represents a single lineage. The relative area of each tile represents the number of sequenced genomes assigned to each lineage.
\
\
\
```{r, echo=FALSE, fig.height=7, fig.width=8}
pl.lin
```
\
\
\
```{rm include = F}
#placeholder
```


## Table of Pango Lineage Frequencies, January 1, 2021 - `r prev.epiwk.end.txt`


<p>*Note: Interpret with caution as there have been several changes in sequencing strategies over this time period.*</p>

\

```{r Change in Pango Lineages, results='asis', echo=FALSE}

# For each lineage create a dataframe to calculate the number and % of genomes
# For each lineage create a dataframe to calculate the change since last report, N and %
lin.changes.since.last <- meta.df.2 %>%
                            mutate(time.cat.new = ifelse(!is.na(Processed_results_date) &
                                                 (Processed_results_date >= prev.epiwk$d0 & 
                                                  Processed_results_date <= prev.epiwk$d1), 
                                                 "New",  "Old")) %>% 
                            filter(Login.Date >= "2021-01-01")  %>% 
                            filter(!is.na(lineage.all) & 
                                     lineage.all != "None") %>%   ##Why passes QC and doesn't have lineage?? Check!
                            group_by(lineage.all, time.cat.new) %>%
                            dplyr::summarise(n.grp = n()) %>%
                            ungroup() %>%
                            mutate(tot = sum(n.grp)) %>%
                            group_by(lineage.all) %>%
                            mutate(tot.lin = sum(n.grp)) %>%
                            spread(time.cat.new, n.grp, fill = 0) %>%
                            mutate(rel.freq = format(round(100*(tot.lin/tot)), nsmall = 2, trim = TRUE)) %>%
                            mutate(perc.chng.num = round(100*(New/(New+Old)))) %>%
                            mutate(perc.chng = format(round(100*(New/(New+Old))), nsmall = 2, trim = TRUE)) %>%
                            mutate(Category = ifelse(lineage.all %in% voc.list, "VOC", 
                                              ifelse(lineage.all %in% voi.list, "VOI", ""))) %>%
                            mutate(rank.ord = ifelse(New >= 10, 1, 0)) %>%
                            arrange(desc(rank.ord), desc(perc.chng.num)) %>%
                            mutate(`N501Y*` = ifelse(lineage.all %in% n501y.lin.list, "&#10003;", ""),
                                   `E484K*` = ifelse(lineage.all %in% e484k.lin.list, "&#10003;", "")) %>%
                            dplyr::select(Category, Lineage = lineage.all, `N501Y*`, `E484K*`,  tot.lin, rel.freq,
                                   New, perc.chng)


# Create a container
sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, 'Category'),
      th(rowspan = 2, 'Lineage'),
      th(rowspan = 2, 'N501Y*'),
      th(rowspan = 2, 'E484K*'),
      th(colspan = 2, 'Total Genomes', style = "border-right: solid 6px #595959; margin-right: 20px; 
                                                border-bottom: solid 1px white; width: 25%;"),
      th(colspan = 2, 'Change in Genomes (since last report)', style = "border-left: solid 6px #595959;
                                                                        border-bottom: solid 1px white; width: 25%;")
    ),
    tr(lapply(rep(c('N', '%'), 2), th)
    )
  )
))
#style = list(marginLeft = "20px")
#background: green;

# Generate table
datatable(lin.changes.since.last,
           container = sketch, 
           rownames = FALSE,
           escape=FALSE,
          caption = htmltools::tags$caption(
              style = 'caption-side: bottom; text-align: left; font-size: 13px;', 
              htmltools::em("*Check indicates that \U2265 80% of publicly available genomes for a given lineage contain the mutation (Data Source: https://outbreak.info)", html_escape = FALSE)
            ),
          class="compact",
          width = 800, 
            options = list(pageLength = 10,
                    columnDefs = list(
                                      list(className = 'dt-center', targets = 0),
                                      list(className = 'dt-left', targets = 1),
                                      list(className = 'dt-center', targets = 2:7)),
                    initComplete = JS(
                              "function(settings, json) {",
                              "$(this.api().table().header()).css({'color': 'white'});",
                              "}"))) #%>% 
 # formatStyle(c(1,3), `border-right` = "solid 2px red")


```

\
\


## Lineage Categories by Epidemiological Week 

<p>Details of the Pango lineage categories can be found in the [Technical Notes](#technical-notes).</p>


```{r, echo=F, message=F, warning=F, fig.width=16, fig.height=8.5}


# ---- VOC/VOIs by Epi week barplot ----

# The y-axis is autoscaled based on code 
meta.df.all.wks %>% 
        group_by(epi.wk.login, lineage.all.cat) %>%
        dplyr::summarise(n = n()) %>%
          ggplot(aes(x = epi.wk.login, y = n, fill = lineage.all.cat)) +
             geom_rect(aes(xmin = which(epiwk.list.all==end.epi.wk)-6.5,
                                 xmax = which(epiwk.list.all==end.epi.wk)+0.5,
                                 ymin=-Inf, ymax=Inf),
                                 fill="grey90") + 
              ggtitle("Subject to \nsequencing lag") +
              geom_bar(stat = "identity") +
                  theme(panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.background = element_blank(),
                        plot.margin = unit(c(5,0,0,0), "lines"),
                        axis.line = element_line(color="black"),
                        legend.text=element_text(size=18),
                        legend.title=element_text(size=18, face = "bold"),
                        legend.position=c(0.1, 0.9),
                        legend.box = "vertical",
                        legend.box.margin = margin(0.05,0.05,0.05,0.05,"cm"),
                        legend.box.background = element_rect(colour = "black"),
                        legend.spacing.y = unit(0.3, "cm"),
                        legend.key.width = unit(0.6, "cm"),
                        legend.key.height = unit(0.3, "cm"),
                        plot.title = element_text(size = 14, hjust = 1),
                        axis.text.y = element_text(size = 17),
                        axis.text.x = element_text(size = 17, angle = 90, hjust = 1, vjust = 0.5),
                        axis.title.y = element_text(size = 19),
                        axis.title.x = element_text(size = 19, margin = margin(t = 20, r = 0, b = 0, l = 0)),
                        legend.spacing.x = unit(0.3, 'cm')) +
                scale_fill_manual("Lineage Category",
                                values = c("VOC" = "#4B91A5", "VOI" = "#D4999A",
                                           "Other" = "#621C4E", "None" = "#B7B7B7"), 
                                breaks = c("VOC", "VOI", "Other", "None")) +
                scale_y_continuous("Number of genomes", expand = c(0,10), 
                                    limits = c(0, max(y.labs.scale)),     
                                    breaks = y.labs.scale, labels = y.labs.scale) +
                scale_x_discrete("Epidemiological week", expand = c(0,0.5)) + 
                coord_capped_cart(left='both', bottom = 'right')

```
\
\
\

***


# Variants of Concern (VOC)

Cumulative counts of genome sequences for each lineage designated as a VOC (January 1, 2021 - `r prev.epiwk.end.txt`).\
A list of the current Pango lineages classified as a VOC can be found in the [Technical Notes](#technical-notes). 

<p> </p>

*Note: Interpret with caution as there have been several changes in sequencing strategies over this time period.*

```{r, include = FALSE, echo=FALSE}


# Create a dataframe for 2021
epiwk.list.2021.df <- data.frame(epiwk.list.2021)


# Create a dataframe that completes all weeks (including those that have zero genomes)
meta.df.all.2021.wks <- meta.df.2021 %>% 
                          right_join(., epiwk.list.2021.df, 
                                     by = c("epi.wk.login" = "epiwk.list.2021")) %>% 
                          select(WGS_Id, epi.wk.2021.login = epi.wk.login, lineage.all)


# Count VOCs by login date
subset.voc.date <- meta.df.all.2021.wks %>%
                    filter(!is.na(lineage.all) & lineage.all != "None") %>%
                    filter(lineage.all %in% voc.list) %>%
                      arrange(epi.wk.2021.login) %>%
                      group_by(lineage.all, epi.wk.2021.login) %>% 
                      dplyr::summarise(lin.counts = n())

# Create cumulative count of VOCs by login date
rolling.cases <- subset.voc.date %>% 
                        group_by(lineage.all, .drop = FALSE) %>%
                        mutate(cumcases = cumsum(lin.counts)) %>%
                        dplyr::select(lineage = lineage.all, epi.wk.2021.login, lin.counts, cumcases) #%>%
                        #mutate(lineage = factor(lineage, levels=c("P.1","B.1.351", "B.1.1.7")))


# Make a preliminary plot to extract autoscales for B.1.1.7
pl.B117.n <- rolling.cases %>%
              filter(lineage == "B.1.1.7") %>%
              ggplot(aes(x = epi.wk.2021.login, y = cumcases)) +
              geom_line(color='black',  group = 1) +
              geom_point(size = 3) +
              scale_y_continuous("Number of genomes", expand = c(0,10)) +
              expand_limits(y = 0)


# # Extract automatic scale
y.B117.labs <- ggplot_build(pl.B117.n)$layout$panel_params[[1]]$y$get_labels()
y.B117.labs.intv <- y.B117.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      mutate(max.lab = max(as.numeric(.))) %>%
                      mutate(intv=max.lab/(n()-1)) %>%
                      distinct(intv)

y.B117.labs.scale <- y.B117.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      rename(intv = ".") %>%
                      mutate(intv = as.numeric(intv)) %>%
                      add_row(intv = y.B117.labs.intv$intv + max(.$intv))%>%
                      pull()


## Make a preliminary plot to extract autoscales for B.1.351
pl.B1351.n <- rolling.cases %>%
              filter(lineage == "B.1.351") %>%
              ggplot(aes(x = epi.wk.2021.login, y = cumcases)) +
              geom_line(color='black',  group = 1) +
              geom_point(size = 3) +
              scale_y_continuous("Number of genomes", expand = c(0,10)) +
              expand_limits(y = 0)


# # Extract automatic scale
y.B1351.labs <- ggplot_build(pl.B1351.n)$layout$panel_params[[1]]$y$get_labels()
y.B1351.labs.intv <- y.B1351.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      mutate(max.lab = max(as.numeric(.))) %>%
                      mutate(intv=max.lab/(n()-1)) %>%
                      distinct(intv)

y.B1351.labs.scale <- y.B1351.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      rename(intv = ".") %>%
                      mutate(intv = as.numeric(intv)) %>%
                      add_row(intv = y.B1351.labs.intv$intv + max(.$intv))%>%
                      pull()


## Make a preliminary plot to extract autoscales for P.1
pl.P1.n <- rolling.cases %>%
              filter(lineage == "P.1") %>%
              ggplot(aes(x = epi.wk.2021.login, y = cumcases)) +
              geom_line(color='black',  group = 1) +
              geom_point(size = 3) +
              scale_y_continuous("Number of genomes", expand = c(0,10)) +
              expand_limits(y = 0)


# # Extract automatic scale
y.P1.labs <- ggplot_build(pl.P1.n)$layout$panel_params[[1]]$y$get_labels()
y.P1.labs.intv <- y.P1.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      mutate(max.lab = max(as.numeric(.))) %>%
                      mutate(intv=max.lab/(n()-1)) %>%
                      distinct(intv)

y.P1.labs.scale <- y.P1.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      rename(intv = ".") %>%
                      mutate(intv = as.numeric(intv)) %>%
                      add_row(intv = y.P1.labs.intv$intv + max(.$intv))%>%
                      pull()


# Make a preliminary plot to extract autoscales for B.1.617.1
pl.B16171.n <- rolling.cases %>%
                filter(lineage == "B.1.617.1") %>%
                ggplot(aes(x = epi.wk.2021.login, y = cumcases)) +
                geom_line(color='black',  group = 1) +
                geom_point(size = 3) +
                scale_y_continuous("Number of genomes", expand = c(0,1)) +
                expand_limits(y = 0)


# # Extract automatic scale
y.B16171.labs <- ggplot_build(pl.B16171.n)$layout$panel_params[[1]]$y$get_labels()
y.B16171.labs.intv <- y.B16171.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      mutate(max.lab = max(as.numeric(.))) %>%
                      mutate(intv=max.lab/(n()-1)) %>%
                      distinct(intv)

y.B16171.labs.scale <- y.B16171.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      rename(intv = ".") %>%
                      mutate(intv = as.numeric(intv)) %>%
                      add_row(intv = y.B16171.labs.intv$intv + max(.$intv))%>%
                      pull()


# Make a preliminary plot to extract autoscales for B.1.617.2
pl.B16172.n <- rolling.cases %>%
              filter(lineage == "B.1.617.2") %>%
              ggplot(aes(x = epi.wk.2021.login, y = cumcases)) +
              geom_line(color='black',  group = 1) +
              geom_point(size = 3) +
              scale_y_continuous("Number of genomes", expand = c(0,1)) +
              expand_limits(y = 0)


# # Extract automatic scale
y.B16172.labs <- ggplot_build(pl.B16172.n)$layout$panel_params[[1]]$y$get_labels()
y.B16172.labs.intv <- y.B16172.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      mutate(max.lab = max(as.numeric(.))) %>%
                      mutate(intv=max.lab/(n()-1)) %>%
                      distinct(intv)

y.B16172.labs.scale <- y.B16172.labs %>%
                      as.data.frame() %>%
                      filter(!is.na(.)) %>%
                      rename(intv = ".") %>%
                      mutate(intv = as.numeric(intv)) %>%
                      add_row(intv = y.B16172.labs.intv$intv + max(.$intv))%>%
                      pull()


# colour palette for VOCs
voc.pal <- c("B.1.1.7" = "#4B91A5",
             "B.1.351" = "#76B5BE",
             "P.1" = "#67223F",
             "B.1.617.1" = "#3F869E",
             "B.1.617.2" = "#95CCCF")
  
# Define common theme
voc.theme <- theme(axis.text.x = element_text(size = 9, angle = 90, hjust = 1, vjust = 0.5),
                   axis.text.y = element_text(size = 10),
                   title = element_text(size = 14),
                   axis.title.x = element_text(vjust=-0.5, size = 10),
                   panel.spacing = unit(1.5, "lines"),
                   panel.border = element_blank(), 
                   axis.title.y = element_text(size = 10),
                   plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
                   legend.position = "none",
                   panel.grid.major = element_blank(), 
                   panel.grid.minor = element_blank(),
                   panel.background = element_blank(), 
                   axis.line = element_line(colour = "black"))

# Create plots
plot.voc.B117 <- rolling.cases %>%
                  filter(lineage == "B.1.1.7") %>%
                  ggplot(aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
                  geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-8.5,
                  xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
                  ymin=-Inf, ymax=Inf),
                  fill="grey90", colour = "grey90") +
                  annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
                           y = Inf,
                  label = "Subject to \nsequencing lag",
                  size = 3, vjust = 8.5, hjust = 0.1, color = "black") +  #hjust = -0.5, hjust = -1, 
                  geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases, group = 1)) +
                  geom_point(size = 3) +
                  ggtitle("B.1.1.7") +
                  voc.theme +
                  scale_color_manual(values = c(voc.pal)) +
                  scale_x_discrete("Epidemiological week", 
                                    expand = c(0,0.5), limits = epiwk.list.2021)  +
                  scale_y_continuous("Cumulative number of genomes", expand = c(0.03,0), 
                                    limits = c(0, max(y.B117.labs.scale)),     
                                    breaks = y.B117.labs.scale, labels = y.B117.labs.scale) + 
                  coord_capped_cart(left='both', bottom = 'both')
  


# Create plots
plot.voc.B1351 <- rolling.cases %>%
                  filter(lineage == "B.1.351") %>%
                  ggplot(aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
                  geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-8.5,
                  xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
                  ymin=-Inf, ymax=Inf),
                  fill="grey90", colour = "grey90") +
                  annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
                           y = Inf,
                  label = "Subject to \nsequencing lag",
                  size = 3, vjust = 8.5, hjust = 0.1, color = "black") +
                  geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases, group = 1)) +
                  geom_point(size = 3) +
                          ggtitle("B.1.351") +
                    voc.theme +
                    scale_color_manual(values = c(voc.pal)) +
                    scale_x_discrete("Epidemiological week", 
                                           expand = c(0,0.5), limits = epiwk.list.2021) +
                    scale_y_continuous("Cumulative number of genomes", expand = c(0.03,0), 
                                    limits = c(0, max(y.B1351.labs.scale)),     
                                    breaks = y.B1351.labs.scale, labels = y.B1351.labs.scale) + 
                    coord_capped_cart(left='both', bottom = 'both')  


# Create plots
plot.voc.P1 <- rolling.cases %>%
                  filter(lineage == "P.1") %>%
                  ggplot(aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
                  geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-8.5,
                  xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
                  ymin=-Inf, ymax=Inf),
                  fill="grey90", colour = "grey90") +
                  annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
                           y = Inf,
                  label = "Subject to \nsequencing lag",
                  size = 3, vjust = 8.5, hjust = 0.1, color = "black") +
                  geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases, group = 1)) +
                  geom_point(size = 3) +
                   ggtitle("P.1") +
                    voc.theme +
                    scale_color_manual(values = c(voc.pal)) +

                     scale_x_discrete("Epidemiological week", 
                                           expand = c(0,0.5), limits = epiwk.list.2021) +
                     scale_y_continuous("Cumulative number of genomes", expand = c(0.03,0), 
                                    limits = c(0, max(y.P1.labs.scale)),     
                                    breaks = y.P1.labs.scale, labels = y.P1.labs.scale) + 
                     coord_capped_cart(left='both', bottom = 'both') 


# Create plots
plot.voc.B16171 <- rolling.cases %>%
                  filter(lineage == "B.1.617.1") %>%
                  ggplot(aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
                  geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-8.5,
                  xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
                  ymin=-Inf, ymax=Inf),
                  fill="grey90", colour = "grey90") +
                  annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
                           y = Inf,
                  label = "Subject to \nsequencing lag",
                  size = 3, vjust = 8.5, hjust = 0.1, color = "black") +
                  geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases, group = 1)) +
                  geom_point(size = 3) +
                   ggtitle("B.1.617.1") +
                    voc.theme +
                    scale_color_manual(values = c(voc.pal)) +
                     scale_x_discrete("Epidemiological week", 
                                           expand = c(0,0.5), limits = epiwk.list.2021) +
                     scale_y_continuous("Cumulative number of genomes", expand = c(0.03,0), 
                                    limits = c(0, max(y.B16171.labs.scale)),     
                                    breaks = y.B16171.labs.scale, labels = y.B16171.labs.scale) + 
                     coord_capped_cart(left='both', bottom = 'both')

# Create plots
plot.voc.B16172 <- rolling.cases %>%
                  filter(lineage == "B.1.617.2") %>%
                  ggplot(aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
                  geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-8.5,
                  xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
                  ymin=-Inf, ymax=Inf),
                  fill="grey90", colour = "grey90") +
                  annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
                           y = Inf,
                  label = "Subject to \nsequencing lag",
                  size = 3, vjust = 8.5, hjust = 0.1, color = "black") +
                  geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases, group = 1)) +
                  geom_point(size = 3) +
                   ggtitle("B.1.617.2") +
                    voc.theme +
                    scale_color_manual(values = c(voc.pal)) +
                     scale_x_discrete("Epidemiological week", 
                                           expand = c(0,0.5), limits = epiwk.list.2021) +
                     scale_y_continuous("Cumulative number of genomes", expand = c(0.03,0), 
                                    limits = c(0, max(y.B16172.labs.scale)),     
                                    breaks = y.B16172.labs.scale, labels = y.B16172.labs.scale) + 
                     coord_capped_cart(left='both', bottom = 'both') 

                
```
\
\
```{r, warning=FALSE, fig.height=3.5, fig.width=8, echo=FALSE, message=F}
plot.voc.B117
plot.voc.B1351
plot.voc.P1
# plot.voc.B16171
plot.voc.B16172
```
\
\

***

<br> 
<br> 


## VOC Relative Frequency by Public Health Unit {.tabset}

```{r, include = F}
# placeholder
```
\
\


### B.1.1.7
```{r pie charts b117, echo=FALSE, fig.width=8.5}

pie_chart_B.1.1.7


```

<br> 
<br> 

### B.1.351
```{r pie charts b1351, echo=FALSE, fig.width=8.5}

pie_chart_B.1.351


```

<br> 
<br> 


### P.1

```{r pie charts p1, echo=FALSE, fig.width=8.5}

pie_chart_P.1


```

<br> 
<br> 


### B.1.617.1

```{r pie charts b16172, echo=FALSE, fig.width=8.5}

pie_chart_B.1.617.2

```

```{r, include = F}
# placeholder
```



```{r, echo=FALSE, include = FALSE}

mutations <- c("S:N501Y", "S:E484K")

nextclade_qc50 <- nextclade_data[nextclade_data$seqName %in% meta.df.2$WGS_Id,]

# search for all mutations using grepl
nextclade_with_mut <- nextclade_qc50[grepl(paste(mutations,collapse="|"), 
                                           nextclade_qc50$aaSubstitutions),]

# remove any object matching pattern for concatenation
rm(list=ls(pattern="^mutation_frame.*"))

# create a mutation frame for each mutation with the samples containing the mutation
for (i in mutations) {
  nextclade_with_mut <- nextclade_qc50[grepl(i, nextclade_qc50$aaSubstitutions),]
  nextclade_with_mut$lineage <- i
  name <- paste("mutation_frame_", i, sep="")
  assign(name, nextclade_with_mut)
}

# bind all mutation frames
df_list <- mget(ls(pattern = "^mutation_frame.*"))
all_muts <- plyr::rbind.fill(df_list)

muts_frame_keep <- subset(all_muts, select = c(seqName, lineage))

mut_merged <- merge(meta.df.2, muts_frame_keep, by.x = "WGS_Id",
                    by.y = "seqName")

mut_lin_rolling_date <- subset(mut_merged, select = c(WGS_Id, lineage.all,
                                                      Login.Date, lineage))

colnames(mut_lin_rolling_date) <- c("name", "lineage", "date", "mutation")
print(mut_lin_rolling_date)
```

```{r, fig.width = 22, fig.height = 10, echo=F, message=F, warning=F, include=FALSE}

for (i in voc.list) {
  health_region_over_time <- subset(meta.df.2021, lineage.all == i) %>%
  group_by(epi.wk.login, HEALTH_UNIT_REPORTABLE) %>% dplyr::summarise(Samples = n())
  health_region_over_time$Cum <- cumsum(health_region_over_time$Samples)
  plot_name <- paste("health_unit_time", i, sep="_")
  p_unit <- ggplot(health_region_over_time, aes(x = epi.wk.login, y = Samples, fill =
                                           HEALTH_UNIT_REPORTABLE)) +
  geom_bar(stat = "identity") +
  theme_bw() + theme(axis.text.x = element_text(angle = 0, size = 16),
                     axis.text.y = element_text(size = 16),
                     title = element_text(size = 18),
                     axis.title.x = element_text(vjust=-0.5, size = 16),
                     strip.text = element_text(size = 14),
                     legend.title = element_text(size = 16),
        legend.text = element_text(size = 14),
        axis.title.y = element_text(size = 16),
        plot.title = element_text(size = 24),
        plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  xlab("Epidemiological week") + ggtitle(paste("Health Unit Distribution by epi week,", i, sep=" ")) +
    labs(fill = "Health Unit")
  assign(plot_name, p_unit)
}

health_unit_time_B.1.1.7

health_unit_time_B.1.351

health_unit_time_P.1


```


```{r, echo=FALSE, include = FALSE, message=FALSE}

mut_lin_date_grouped <- mut_lin_rolling_date %>% arrange(date) %>%
                          group_by(mutation, lineage, date) %>%
                          dplyr::summarise(counts = n())

mut_lin_date_grouped_final <- mut_lin_date_grouped %>% 
                                  group_by(mutation, lineage) %>%
                                  mutate(cumcases = cumsum(counts))

# set 501 mutation to come before 484
mut_lin_date_grouped_final$mutation <- factor(mut_lin_date_grouped_final$mutation,
                                                 levels = c("S:N501Y", "S:E484K"))

mut_lin_date_grouped_final_voc <- mut_lin_date_grouped_final[mut_lin_date_grouped_final$lineage %in% 
                                                               c("P.1", "B.1.351"),]

# get the most recent date for each of the lineages by mutation
max_date_each_lin_voc <- mut_lin_date_grouped_final_voc %>% 
                            group_by(mutation, lineage) %>% 
                            filter(date == max(date))

# plot the lineages separately for each mutation
# include a label at the most recent date of logging for each mutation
plot_voc_no_b117 <- ggplot(mut_lin_date_grouped_final_voc, aes(x = date, y = cumcases, col = lineage)) +
                      geom_point(data = max_date_each_lin_voc, aes(color = lineage)) +
                      geom_line() + facet_wrap(~mutation, ncol = 2) + ylab("Case Counts") +
                      xlab("Login Date") +
                      theme(text = element_text(size=20),
                            axis.title.x = element_text(vjust=-0.5),
                            plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
                            panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                            panel.background = element_blank(), axis.line = element_line(colour = "black")) +
                      geom_text_repel(data = max_date_each_lin_voc,
                                      aes(label = paste(lineage, paste("(", cumcases, ")", sep = ""), 
                                                        sep = " ")), hjust = 0, 
                                      nudge_x = 0.05, size = 5, col = "black") +
                      ggtitle("Cumulative Counts of VOC Lineages with Mutations of Interest, no B.1.1.7") +
                      scale_x_date(date_labels = "%b-%Y")


mut_lin_date_grouped_final_non_voc <- mut_lin_date_grouped_final[!mut_lin_date_grouped_final$lineage %in% 
                                                                   c("P.1", "B.1.351", "B.1.1.7"),]

# get the most recent date for each of the lineages by mutation
max_date_each_lin_non_voc <- mut_lin_date_grouped_final_non_voc %>% 
                              group_by(mutation, lineage) %>% 
                              filter(date == max(date))

# plot the lineages separately for each mutation
# include a label at the most recent date of logging for each mutation
plot_non_voc <- ggplot(mut_lin_date_grouped_final_non_voc, aes(x = date, y = cumcases, col = lineage)) +
                    geom_point(data = max_date_each_lin_non_voc, aes(color = lineage)) +
                    geom_line() + facet_wrap(~mutation, ncol = 2) + ylab("Case Counts") +
                    xlab("Login Date") +
                    theme(text = element_text(size=20),
                          axis.title.x = element_text(vjust=-0.5),
                          plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
                          panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                          panel.background = element_blank(), axis.line = element_line(colour = "black")) +
                    geom_text_repel(data = max_date_each_lin_non_voc,
                                    aes(label = paste(lineage, paste("(", cumcases, ")", 
                                                                     sep = ""), sep = " ")), hjust = 0, 
                                                                     nudge_x = 0.05, size = 5, col = "black") +
                    ggtitle("Cumulative Counts of non-VOC Lineages with Mutations of Interest") +
                    scale_x_date(date_labels = "%b-%Y")

                  
mut_lin_date_grouped_final_b117 <- mut_lin_date_grouped_final[mut_lin_date_grouped_final$lineage == "B.1.1.7",]
                  
# get the most recent date for each of the lineages by mutation to assign labels
max_date_each_lin_b117 <- mut_lin_date_grouped_final_b117 %>% 
                            group_by(mutation, lineage) %>% 
                            filter(date == max(date))
                  
plot_b117 <- ggplot(mut_lin_date_grouped_final_b117, aes(x = date, y = cumcases, col = lineage)) +
                    geom_point(data = max_date_each_lin_b117, aes(color = lineage)) +
                    geom_line() + facet_wrap(~mutation, ncol = 2) + ylab("Case Counts") +
                    xlab("Login Date") +
                    theme(text = element_text(size=20),
                          axis.title.x = element_text(vjust=-0.5, size = 20),
                          plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
                          panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                          panel.background = element_blank(), axis.line = element_line(colour = "black")) +
                    geom_text_repel(data = max_date_each_lin_b117,
                                    aes(label = paste(lineage, 
                                                      paste("(", cumcases, ")", sep = ""), sep = " ")), 
                                    hjust = 0, nudge_x = 0.05, size = 5, col = "black") +
                    ggtitle("Cumulative Counts of Lineages with Mutations of Interest, B.1.1.7") +
                    scale_x_date(date_labels = "%b-%Y")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=12.5, fig.width=17, include=F}
plot_b117
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=16, fig.width=17,include=F}
plot_voc_no_b117
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=12.5, fig.width=17, include=F}
plot_non_voc
```

<br> 
<br> 

# Variants of Interest (VOI)

```{r, include = FALSE, echo=FALSE}


# subset._voi.date <- subset(meta.df.2021, lineage.all %in% voi.list & lineage.all != "None") %>%
#                     arrange(Login.Date) %>%
#                     group_by(lineage.all, Login.Date) %>% 
#                     dplyr::summarise(lin_counts = n())
# 
# rolling_cases_voi <- subset_voi_date %>% 
#                       group_by(lineage.all, .drop = FALSE) %>%
#                       mutate

# Count VOIs by login date
subset.voi.date <- meta.df.all.2021.wks %>%
                    filter(!is.na(lineage.all) & lineage.all != "None") %>%
                    filter(lineage.all %in% voi.list) %>%
                      arrange(epi.wk.2021.login) %>%
                      group_by(lineage.all, epi.wk.2021.login) %>% 
                      dplyr::summarise(lin.counts = n())

# Create cumulative count of VOCs by login date
rolling.cases.voi <- subset.voi.date %>% 
                      group_by(lineage.all, .drop = FALSE) %>%
                      mutate(cumcases = cumsum(lin.counts)) %>%
                      dplyr::select(lineage = lineage.all, epi.wk.2021.login, lin.counts, cumcases) %>%
                      mutate(lineage = factor(lineage, levels=c("B.1.1.318", "B.1.525", "B.1.526", "B.1.526.1",
                      "P.2", "P.3", "A.23.1 with E484K", 
                      "B.1.2 with E484K",
                      "R.1", "B.1.427", "B.1.429",
                      "B.1.617", "B.1.617.1", "B.1.617.2", "B.1.617.3")))


#setnames(rolling.cases.voi, old = c('lineage.all'), new = c('lineage'))

# max_date_each_voi <- rolling.cases.voi %>% 
#                       group_by(lineage) %>% 
#                       filter(Login.Date == max(Login.Date))

# colour palette for VOIs
voi.pal <- c("#ff8c8a","#00c18e","#940295","#d49500", 
             "#0254cf","#765900","#7848ce","#f1bc81","#c3006c","#fcb69c","#ff89e1","#824025")

## get the start and end points for highlighted regions

  # start point = 3 weeks before most recent login date

# start.s5 <- (max(rolling.cases.voi$epi.wk.2021.login) - 6)
# 
#   # end point = most recent login date
# 
# end.s5 <- max(rolling.cases.voi$epi.wk.2021.login)
# 
#   # create rectangle frame to call for figure
# 
# rect.s5 <- data.frame(xmin= (start.s5), xmax= (end.s5), ymin=-Inf, ymax=Inf)

# set this specific order to place the blank cell next to b117 and have other 
# two vocs on separate line
rolling.cases.voi$lin.fac <- factor(rolling.cases.voi$lineage, 
                                    levels=c("P.2", "P.3", "B.1.525", 
                                             "R.1", "B.1.1.318", "B.1.427", "B.1.429", "B.1.526",
                                              "B.1.617", "B.1.617.1", "B.1.617.2", "B.1.617.3"))


# plot_voi <- ggplot(rolling.cases.voi, aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
#               # facet wrap with as fable allows for blank cell in col 2 cell 1
#               # https://stackoverflow.com/questions/56447366/ordering-placement-of-empty-facet-when-using-facet-wrap
#               # facet_rep_wrap(~lineage, ncol=1, scales = "free_y", as.table = F, 
#               #                repeat.tick.labels = 'bottom') +
#               geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-7.5,
#               xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
#               ymin=-Inf, ymax=Inf),
#               fill="grey90", colour = "grey90") +
#               annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
#                        y = Inf,
#               label = "Subject to \nsequencing lag",
#               size = 3, vjust = 10, hjust = -.03, color = "black") +
#                 #size = 3, vjust = 1.2, hjust = -.03, color = "black") +
#               geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases)) +
#               geom_point(size = 3) +
#               theme_bw() + 
#               theme(axis.text.x = element_text(size = 10, angle = 90, hjust = 1, vjust = 0.5),
#                                    axis.text.y = element_text(size = 10),
#                                    #title = element_text(size = 16),
#                                    axis.title.x = element_text(vjust=-0.5, size = 14),
#                                    strip.text = element_text(size = 16, face="bold", hjust = 0),
#                                    panel.spacing = unit(1.5, "lines"),
#                                    panel.border = element_blank(), 
#                                    axis.title.y = element_text(size = 10),
#                                    plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#                                    legend.position = "left",
#                                    panel.grid.major = element_blank(), 
#                                    panel.grid.minor = element_blank(),
#                                    panel.background = element_blank(), 
#                                    axis.line = element_line(colour = "black"),
#                       strip.background =element_rect(fill = NA, colour = NA)) +
#                       scale_color_manual(values = c(voi.pal)) +
#                       xlab("Login Date") +
#                       ylab("Cumulative number of genomes") + 
#                       scale_x_discrete("Epidemiological week", 
#                                        expand = c(0,0.5), limits = epiwk.list.2021) + 
#                       #scale_x_date(date_labels = "%b-%Y") +
#                       coord_capped_cart(left='both', bottom = 'both') 

# ggplot(rolling.cases.voi, aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
#               # facet wrap with as fable allows for blank cell in col 2 cell 1
#               # https://stackoverflow.com/questions/56447366/ordering-placement-of-empty-facet-when-using-facet-wrap
#               # facet_rep_wrap(~lineage, ncol=1, scales = "free_y", as.table = F, 
#               #                repeat.tick.labels = 'bottom') +
#               geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-7.5,
#               xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
#               ymin=-Inf, ymax=Inf),
#               fill="grey90", colour = "grey90") +
#               annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
#                        y = Inf,
#               label = "Subject to \nsequencing lag",
#               size = 3, vjust = 10, hjust = -.03, color = "black") +
#                 #size = 3, vjust = 1.2, hjust = -.03, color = "black") +
#               geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases)) +
#               geom_point(size = 3) +
#               theme_bw() + 
#               theme(axis.text.x = element_text(size = 10, angle = 90, hjust = 1, vjust = 0.5),
#                                    axis.text.y = element_text(size = 10),
#                                    #title = element_text(size = 16),
#                                    axis.title.x = element_text(vjust=-0.5, size = 14),
#                                    strip.text = element_text(size = 16, face="bold", hjust = 0),
#                                    panel.spacing = unit(1.5, "lines"),
#                                    panel.border = element_blank(), 
#                                    axis.title.y = element_text(size = 10),
#                                    plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#                                    legend.position = "left",
#                                    panel.grid.major = element_blank(), 
#                                    panel.grid.minor = element_blank(),
#                                    panel.background = element_blank(), 
#                                    axis.line = element_line(colour = "black"),
#                       strip.background =element_rect(fill = NA, colour = NA)) +
#                       scale_color_manual(values = c(voi.pal)) +
#                       xlab("Login Date") +
#                       ylab("Cumulative number of genomes") + 
#                       scale_x_discrete("Epidemiological week", 
#                                        expand = c(0,0.5), limits = epiwk.list.2021) + 
#                       #scale_x_date(date_labels = "%b-%Y") +
#                       coord_capped_cart(left='both', bottom = 'both') 


# Create a dataframe that completes all weeks (including those that have zero genomes)
# meta.df.all.wks <- meta.df.2 %>% 
#                     right_join(., epiwk.list.all.df, by = c("epi.wk.login" = "epiwk.list.all")) %>% 
#                     select(WGS_Id, epi.wk.login, lineage.all, lineage.all.cat)

# z<- meta.df.all.2021.wks %>% 
#         filter(lineage.all %in% voi.list) %>%
#         group_by(epi.wk.2021.login, lineage.all) %>%
#         dplyr::summarise(n = n()) %>%
#           ggplot(aes(x = epi.wk.login, y = n, fill = lineage.all)) +
#              # geom_rect(aes(xmin = which(epiwk.list.all==end.epi.wk)-7.5,
#              #                     xmax = which(epiwk.list.all==end.epi.wk)+0.5,
#              #                     ymin=-Inf, ymax=Inf),
#              #                     fill="grey90") + 
#              #                     annotate("text", x = which(epiwk.list.all==end.epi.wk)-7.45, y = Inf, 
#              #                                      label = "Subject to \nsequencing lag",
#              #                                      size = 5, vjust = 1.2, hjust = -.03, color = "black") +
#               geom_bar(stat = "identity") +
#                 #   theme(panel.grid.major = element_blank(),
#                 #         panel.grid.minor = element_blank(),
#                 #         panel.background = element_blank(),
#                 #         plot.margin = unit(c(5,0,0,0), "lines"),
#                 #         axis.line = element_line(color="black"),
#                 #         legend.text=element_text(size=18),
#                 #         legend.title=element_text(size=18, face = "bold"),
#                 #         legend.position=c(0.1, 0.9),
#                 #         legend.box = "vertical",
#                 #         legend.box.margin = margin(0.05,0.05,0.05,0.05,"cm"),
#                 #         legend.box.background = element_rect(colour = "black"),
#                 #         legend.spacing.y = unit(0.3, "cm"),
#                 #         legend.key.width = unit(0.6, "cm"),
#                 #         legend.key.height = unit(0.3, "cm"),
#                 #         axis.text.y = element_text(size = 18),
#                 #         axis.text.x = element_text(size = 18, angle = 90, hjust = 1, vjust = 0.5),
#                 #         axis.title.y = element_text(size = 18),
#                 #         axis.title.x = element_text(size = 18, margin = margin(t = 20, r = 0, b = 0, l = 0)),
#                 #         legend.spacing.x = unit(0.3, 'cm')) +
#                 # scale_fill_manual("Lineage Category",
#                 #                 values = voi.pal) +
#                 #                       scale_y_continuous("Number of genomes", expand = c(0,10), 
#                 #                                          limits = c(0, max(y.labs.scale)),     
#                 #                                          breaks = y.labs.scale, labels = y.labs.scale) +
#                 scale_x_discrete("Epidemiological week", expand = c(0,0.5)) + 
#                 coord_capped_cart(left='both', bottom = 'right')



# plot_voi <- ggplot(rolling.cases.voi, aes(x = Login.Date, y = cumcases, color = lin.fac)) +
#   geom_point(size = 3) + 
#   scale_color_manual(values = c(voi.pal)) +
#   # facet wrap with as fable allows for blank cell in col 2 cell 1
#   # https://stackoverflow.com/questions/56447366/ordering-placement-of-empty-facet-when-using-facet-wrap
#   #facet_wrap(~lin_fac, ncol=1, scales = "free_y", as.table = F) +
#   geom_rect(data=rect.s5, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
#                color="grey30",alpha=0.25, inherit.aes = FALSE) +
#   theme_bw() + theme(axis.text.x = element_text(angle = 0, size = 14),
#                        axis.text.y = element_text(size = 14),
#                        title = element_text(size = 16),
#                        axis.title.x = element_text(vjust=-0.5, size = 16),
#                        strip.text = element_text(size = 18),
#                        axis.title.y = element_text(size = 16),
#                        plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#           legend.position = "none",
#                        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#                        panel.background = element_blank(), axis.line = element_line(colour = "black"),
#           strip.background =element_rect(fill="white")) +
#    geom_line(color='black',data = rolling.cases.voi, aes(x = date, y = cumcases)) +
#      geom_text(data=rect.s5, aes(x = xmin, y = ymin, 
#                                  label = "Samples recieved \nduring this time period\nmay not yet be\nsequenced"), 
#                                   size = 5, vjust = -1, hjust = -0.05, color = "black") +
#     # ggtitle(paste("Watchlist lineages (VOC) as of ", format(last(rolling_cases$date), "%b-%d-%Y"), #    sep="")) +
#     xlab("Login Date") +
#     ylab("Cumulative number of sequences") + scale_x_date(date_labels = "%b-%Y") +
#   scale_y_continuous(breaks = pretty_breaks())



```



<!-- ## VOI Sequence Numbers -->

```{r, results='asis', echo=FALSE, warning=FALSE, , include=F}
# max.counts.voi <- rolling.cases.voi %>% group_by(lin.fac) %>% filter(cumcases == max(cumcases))
# max.counts.voi <- subset(max.counts.voi, select = c(lineage, cumcases)) %>% arrange(-cumcases)
# colnames(max.counts.voi) <- c("Lineage", "Number of Genomes")
# # datatable(as.data.frame(max_counts_voi), extensions = 'Buttons',
# #           options = list(pageLength = 25, dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
# 
# 
# datatable(as.data.frame(max.counts.voi),
#           options = list(pageLength = 10, 
#                    columnDefs = list(list(className = 'dt-left', targets = '_all')),
#                                     # list(className = 'dt-center', targets = 4)),
#                    autowidth = TRUE,initComplete = JS(
#                             "function(settings, json) {",
#                             "$(this.api().table().header()).css({'color': 'white'});",
#                             "}"))) 

```

## VOI Lineage Frequencies by Epidemiological Week
<font size="2"> Includes lineages represented by &#8805;10 genomes </font> 

```{r, include=FALSE}


# cols.voi <- c("#31B98F", "639B8B","#B7B7B7",  "#CF913C", "#819EE9", 
#               "#741F39", "#D49998","#1F343C", "#C144BC", "red", "green",
#               "black")


colourCount = length(voi.list)
getPalette = colorRampPalette(brewer.pal(11, "GnBu"))

# cols.voi <- c("#6B013E","#B2126E", "#CD398D","#DE77AE", "#EAA1CB","#F4C3E1","grey10", "grey50", "grey90", 
#               "#C7DDE3", "#A5C8D2", "#629FB0", "#325F6C")

# cols.voi <- c("#6B013E", "#CD398D", "#EAA1CB","#F4C3E1","grey10", "grey50", "grey70", "grey90", 
#               "#C7DDE3", "#A5C8D2", "#629FB0", "#325F6C")

# cols.voi <- c("#6B013E", "#CD398D", "#EAA1CB","#F4C3E1","grey10", "grey50", "grey70", "grey90", 
#               "#C7DDE3", "#A5C8D2", "#629FB0", "#325F6C")

cols.voi <- c("A.23.1" = "#DBB9EC", "P.2" = "#CB627B", "R.1" = "#B13F63", "B.1.1.318"="#346F8C", 
              "B.1.1.7 with E484K" = "#4389A0", "B.1.2 with E484K" = "#69A5B5", 
              "B.1.525" = "#A6D9D8", "B.1.526" = "#C8ECE7", "B.1.617.1" = "grey50")

# Generate plot of VOIs over epi weeks
plot.voi <- meta.df.2021 %>%
              filter(lineage.all %in% voi.list) %>%
              mutate(lineage = lineage.all) %>%
              right_join(., filter(epiwk.list.all.df, 
                                   grepl("2021", epiwk.list.all)), 
                         by = c("epi.wk.login" = "epiwk.list.all")) %>%
                    group_by(epi.wk.login, lineage) %>%
                    summarise(`Num. genomes` = n()) %>%
                    group_by(lineage) %>%
                    mutate(Tot = sum(`Num. genomes`)) %>% 
                    filter(Tot > 10) %>%
                    ggplot(aes(x = epi.wk.login, y = `Num. genomes`, 
                               fill = lineage, label=lineage, label2=`Num. genomes`)) +
                    #ggplot(aes(x = epi.wk.login, y = n, fill = lineage.all)) +
                      geom_bar(stat = "identity", colour = "white", size = 0.05) + 
                        theme(panel.grid.major = element_blank(),
                                    panel.grid.minor = element_blank(),
                                    panel.background = element_blank(),
                                    plot.margin = unit(c(0,0,0,0), "cm"),
                                    axis.line = element_line(color="black"),
                                    legend.text=element_text(size=10),
                                    legend.title=element_text(size=10, face = "bold"),
                                           legend.position=c(0.15, 0.65),
                                    legend.box = "vertical",
                                    legend.box.margin = margin(0.05,0.05,0.05,0.05,"cm"),
                                    legend.box.background = element_rect(colour = "black"),
                                    #legend.spacing.y = unit(0.3, "cm"),
                                    #legend.key.width = unit(0.6, "cm"),
                                    #legend.key.height = unit(0.3, "cm"),
                                    axis.text.x = element_text(size = 40, angle = 90, hjust = 1, vjust = 2),
                                    axis.text.y = element_text(size = 10),
                                    axis.title.x = element_text(angle = 0, size = 10,
                                                                margin = margin(t = 30, r = 0, b = 0, l = 0)),
                                    axis.title.y = element_text(size = 10, margin = margin(t = 10, r = 30, b = 0, l = 0))) +
  #scale_fill_manual(values = getPalette(colourCount)) +
                      scale_fill_manual(values = cols.voi, na.translate = F) +
  #scale_fill_brewer(palette = "PiYG") +
                      scale_y_continuous("Number of genomes", 
                                      limits = c(0, 300), 
                                      breaks = c(0, 25, 50, 75, 100, 125, 150, 175, 200, 225, 250,275,300), 
                                      expand = c(0.02, 0)) +
                                      scale_x_discrete("Epidemiological week", expand = c(0,0.5)) + 
                coord_capped_cart(left='both', bottom = 'right') +
                      labs(fill='Pango lineage') + xlab("Epidemiological week") 
                       #scale_fill_paletteer_d(awtools::a_palette)
                       
 
```


```{r, warning=FALSE, fig.width=10, fig.height=5,  echo=FALSE, message=FALSE, include=T}

ggplotly(plot.voi, tooltip = c("label", "label2"), width = 900, height = 450)   %>%
layout(showlegend = TRUE, legend = list(font = list(size = 10)), #, x=15, y=0.5
       xaxis = list(tickfont = list(size = 12),
                    titlefont=list(size=2)),
                    title=list(standoff=100L),
       yaxis = list(tickfont = list(size = 12)))%>% 
  config(displayModeBar = F)



```

*Note: Interpret with caution as there have been several changes in sequencing strategies over this time period.*

\

A list of the current Pango lineages that are classified as VOIs by PHO can be found in the  [Technical Notes](#technical-notes).


\
\

***

<br> 
<br> 

# Mutation distributions

A table comprising the total counts and percentage of samples that have particular mutations can demonstrate the patterns of mutations across both VOC and non-VOC lineages. Characterization of these mutation patterns can assist in revealing the identity of mutations that may contribute to increased levels of clade and lineage transmission.\
\
The percentage represents to the proportion of all samples in the specific category (VOC or non-VOC) that have this mutation detected. Blank cells indicate that the mutation was not yet observed in the particular sample category (VOC or non-VOC) for samples sequenced at PHO. 

<p>Information on the specific mutation profiles of Pango lineages can be found at:
[Outbreak.info](https://outbreak.info/)</p>

<p>*Note: Not all positions in the genome have sufficient depth to enable detection.*<p>

\
\

## Mutation Frequencies for the Spike (S) Gene

```{r, include=FALSE}
# qc50_highest_voc <- meta.df.2021[meta.df.2021$lineage.all %in% voc.list,]
with_change_since_last <- meta.df.2 %>%
                            mutate(time.cat.new = ifelse(!is.na(Processed_results_date) &
                                                 (Processed_results_date >= prev.epiwk$d0 &
                                                  Processed_results_date <= prev.epiwk$d1),
                                                 "New",  "Old")) %>%
                            filter(Login.Date >= "2021-01-01")  %>%
                            filter(!is.na(lineage.all) &
                                     lineage.all != "None")

qc50_highest_voc <- with_change_since_last[with_change_since_last$lineage.all %in% voc.list,]

nextclade_qc50_voc <- nextclade_qc50[nextclade_qc50$seqName %in% qc50_highest_voc$WGS_Id,]



merged_voc_ontario <- merge(qc50_highest_voc, nextclade_qc50_voc, by.x = "WGS_Id",
                                by.y = "seqName")


separation <- unlist(strsplit(as.vector(merged_voc_ontario$aaSubstitutions),
                       split = ","))

all_muts_frame <- data.frame(table(separation))
all_muts_frame$percent_sample <- round(100*(all_muts_frame$Freq / nrow(qc50_highest_voc)), 2)
all_muts_frame$Gene <- str_split_fixed(all_muts_frame$separation, ":", 2)[,1]


# recent voc mutations
recent_voc_ontario <- subset(merged_voc_ontario, time.cat.new == "New")
separation_voc_new <- unlist(strsplit(as.vector(recent_voc_ontario$aaSubstitutions),
                       split = ","))

all_muts_frame_voc_new <- data.frame(table(separation_voc_new))
colnames(all_muts_frame_voc_new) <- c("Mutation", "Number of new Genomes")
all_voc_muts <- merge(all_muts_frame, all_muts_frame_voc_new, by.x = "separation", by.y = "Mutation",
                      all = T)
all_voc_muts$percent_new <- round(100 * all_voc_muts$`Number of new Genomes` / nrow(recent_voc_ontario), 2)
# all_muts_frame_voc_new$percent_sample <- round(100*(all_muts_frame$Freq / nrow(qc50_highest_voc)), 2)
# all_muts_frame$Gene <- str_split_fixed(all_muts_frame$separation, ":", 2)[,1]

colnames(all_voc_muts) <- c("Mutation", "Number of VoC Genomes", "Percent of VoC Genomes", "Gene",
                              "Number of new VoC Genomes", "Percent change (%), New VoC Genomes")

all_voc_muts <- all_voc_muts %>% arrange(-`Percent of VoC Genomes`)

```

```{r, include=FALSE}
qc50_highest_non_voc <- with_change_since_last[! with_change_since_last$lineage.all %in% voc.list,]


nextclade_qc50_non_voc <- nextclade_qc50[nextclade_qc50$seqName %in% qc50_highest_non_voc$WGS_Id,]

merged_non_voc_ontario <- merge(qc50_highest_non_voc, nextclade_qc50_non_voc, by.x = "WGS_Id",
                                by.y = "seqName", all.y = T)

separation <- unlist(strsplit(as.vector(merged_non_voc_ontario$aaSubstitutions),
                       split = ","))

all_muts_frame_no_voc <- data.frame(table(separation))
all_muts_frame_no_voc$percent_sample <- round(100*(all_muts_frame_no_voc$Freq / nrow(qc50_highest_non_voc)), 2)
all_muts_frame_no_voc$Gene <- str_split_fixed(all_muts_frame_no_voc$separation, ":", 2)[,1]

# recent non-voc mutations
recent_non_voc_ontario <- subset(merged_non_voc_ontario, time.cat.new == "New")
separation_non_voc_new <- unlist(strsplit(as.vector(recent_non_voc_ontario$aaSubstitutions),
                       split = ","))

all_muts_frame_non_voc_new <- data.frame(table(separation_non_voc_new))
colnames(all_muts_frame_non_voc_new) <- c("Mutation", "Number of new Genomes")
all_non_voc_muts <- merge(all_muts_frame_no_voc, all_muts_frame_non_voc_new, by.x = "separation", by.y = "Mutation",
                      all = T)
all_non_voc_muts$percent_new <- round(100 * all_non_voc_muts$`Number of new Genomes` / nrow(recent_non_voc_ontario), 2)
# all_muts_frame_voc_new$percent_sample <- round(100*(all_muts_frame$Freq / nrow(qc50_highest_voc)), 2)
# all_muts_frame$Gene <- str_split_fixed(all_muts_frame$separation, ":", 2)[,1]

colnames(all_non_voc_muts) <- c("Mutation", "Number of non-VoC Genomes", "Percent of non-VoC Genomes",
                                "Gene", "Number of new non-VoC Genomes", "Percent change (%), New non VoC Genomes")

all_non_voc_muts <- all_non_voc_muts %>% arrange(-`Percent of non-VoC Genomes`)


```

```{r, results='asis', echo=FALSE,include = F}
merge_mutations <- merge(all_voc_muts, all_non_voc_muts, by.x = "Mutation",
                         by.y = "Mutation", all=T) %>%
                        subset(select=c(-Gene.x)) %>%
                        arrange(-`Percent of VoC Genomes`)
setnames(merge_mutations, "Gene.y", "Gene")
only_spike <- subset(merge_mutations, Gene == "S")
rownames(only_spike) <- NULL
# datatable(as.data.frame(only_spike), extensions = 'Buttons',
#           options = list(pageLength = 25, dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))

only_spike <- only_spike %>%
                dplyr::select(-Gene)

datatable(as.data.frame(only_spike),
          options = list(pageLength = 10,
                   columnDefs = list(list(className = 'dt-left', targets = 1:3),
                                     list(className = 'dt-center', targets = 4)),
                   autowidth = TRUE,initComplete = JS(
                            "function(settings, json) {",
                            "$(this.api().table().header()).css({'color': 'white'});",
                            "}")))

```


```{r, echo = F, warning = F, message = F, fig.height=15}
sketch_muts = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, 'Mutation'),
      th(colspan = 4, 'VoC Genomes', style = "border-right: solid 6px #595959;
                                                border-bottom: solid 1px white;"),
      th(colspan = 4, 'non-VoC Genomes', style = "border-left: solid 6px #595959;
                                                    border-bottom: solid 1px white;")
    ),
    tr(lapply(rep(c('N total', '% total', 'N New*', '% New*'), 2), th)
    )
  )
))

 datatable(as.data.frame(only_spike),
           container = sketch_muts,
           fillContainer = getOption("DT.fillContainer", NULL),
           rownames = FALSE,
          # caption = 'Table 1: This is a simple caption for the table.',
           class="compact",
            options = list(pageLength = 10,
                    columnDefs = list(
                                      list(className = 'dt-center',  targets = 0),
                                      list(className = 'dt-left',  targets = 1),
                                       list(className = 'dt-center',  targets = 2:4),
                                      list(className = 'dt-center',  targets = 5)),
                     autowidth = TRUE, initComplete = JS(
                              "function(settings, json) {",
                              "$(this.api().table().header()).css({'color': 'white'});",
                              "}"))) #%>%
 # formatStyle(c(1,3), `border-right` = "solid 2px red")
```


\
\


***

# Nextstrain Phylogenetic tree URLS

Phylogenetic trees are generated through a statistical procedure that infers the ancestry and
similarity among sequences by considering their mutation profiles among with a model for mutation substitution rates. As such they represent the best possible relationship among a group of samples based on the mutation information available to the model. These relationships should not be considered as absolute, and are subject to biases related to sample quality and depth of sequencing coverage. 

Phylogenetic trees shown through [Nextstrain](https://nextstrain.publichealthontario.ca/ncov/) represent a subset of all samples sequenced at PHO that were selected based on genome completeness and overall high sequencing quality. Therefore the trees may not be reflective of the VOC sample numbers in the province at any specific point in time. 

\
[Nextstrain for PHO B.1.1.7 genomes](https://nextstrain.publichealthontario.ca/ncov/?c=Pango.Lineage&f_Pango.Lineage=B.1.1.7&label=clade:20I/501Y.V1)
\

[Nextstrain for PHO B.1.351 genomes](https://nextstrain.publichealthontario.ca/ncov/?c=Pango.Lineage&f_Pango.Lineage=B.1.351&label=clade:20H/501Y.V2)
\

[Nextstrain for PHO P.1 genomes](https://nextstrain.publichealthontario.ca/ncov/?c=Pango.Lineage&f_Pango.Lineage=P.1&label=clade:20J/501Y.V3)
\

[Nextstrain for PHO B.1.617.2 genomes](https://nextstrain.publichealthontario.ca/ncov/?f_Pango.Lineage=B.1.617.2) \
(**Note: ** Select *Zoom to selected* to view these genomes as they have not yet been assigned to a Nextstrain clade)
\
\




<br>

***

# References

1. Pango Lineages. https://cov-lineages.org/
2. Nextstrain. https://nextstrain.org/
3. Outbreak.info. https://outbreak.info/
\
\


<br>

***

# Technical Notes

## Pango lineage assignment categories
 
\
```{r, fig.height=12, fig.width=13, echo=FALSE}

VOC.df <- data.frame(voc.list)
VOI.df <- data.frame(voi.list) %>% arrange(voi.list)
  
voc.voi.list <- merge(VOI.df, VOC.df, by="row.names", all.x=TRUE)
voc.voi.list <-  voc.voi.list %>% 
                  select(VOC = voc.list, VOI = voi.list) %>% 
                  arrange(VOC, VOI) %>%
                  mutate(VOC = ifelse(!is.na(VOC), VOC, ""))



reactable(as.data.frame(voc.voi.list), 
          outlined = TRUE, 
          borderless = TRUE,
          fullWidth = FALSE,
          pagination = FALSE,
          compact = TRUE, 
          #height = 150,
          columns = list(
    VOC = colDef(width = 200, style = list(paddingLeft = "30px"), 
                 headerStyle = list(background = "#595959", height = 50, paddingTop = "15px", 
                                    paddingLeft = "30px", color = "white")),
    VOI = colDef(width = 200, style = list(paddingLeft = "20px"),
                 headerStyle = list(background = "#595959", height = 50, paddingTop = "15px", 
                                    paddingLeft = "20px", color = "white"))))


#,  #marginLeft = "20px"
    #       theme = reactableTheme(cellPadding = "15px"))
#style = list(marginLeft = "20px"), 

   
# 
# # kable(as.data.frame(voc.voi.list), caption = "Pango lineage designation guide",
# #       align=rep('l', 5))
# 
# datatable(as.data.frame(voc.voi.list), 
#           options = list(pageLength = 20, 
#                    # columnDefs = list(list(className = 'dt-left', targets = 1:3),
#                    #                   list(className = 'dt-center', targets = 4)),
#                    autowidth = TRUE,initComplete = JS(
#                             "function(settings, json) {",
#                             "$(this.api().table().header()).css({'color': 'white'});",
#                             "}"))) 


```
\
\


<br>

***


# Appendix

\

```{r, echo=F, warning=F, message=F}
replace_lineages <- subset(as.data.frame(meta.df), lineage_all != "None" & as.character(lineage_all) !=
                             as.character(lineage_plate) & lineage_plate != "" & lineage_all != "") %>%
                              dplyr::select(Login_Date, lineage_plate, lineage_all)

replace_lineages$reassign <- factor(paste(replace_lineages$lineage_plate, "->", replace_lineages$lineage_all, sep=" "))

replace_lin_grouped <- replace_lineages %>% 
                        group_by(Login_Date, reassign) %>% 
                        dplyr::summarise(counts = n()) %>%
                        group_by(Login_Date, reassign) %>% 
                        dplyr::summarise(cumcounts = cumsum(counts))

dates_reassign <- replace_lineages %>% 
                    group_by(reassign) %>% 
                    dplyr::mutate(counts = n()) %>% 
                    filter(Login_Date == min(Login_Date) | Login_Date == max(Login_Date)) %>% 
                    dplyr::distinct() %>% group_by(reassign) %>%
                    dplyr::mutate(Earliest = min(Login_Date), Latest = max(Login_Date)) %>%
                    dplyr::select(reassign, counts, Earliest, Latest) %>%
                    dplyr::distinct() %>% arrange(-counts)

```

## Pango Lineage re-assignments as of `r format(Sys.time(), '%B %d, %Y')`

Lineage re-assignments reflect changes to lineages designations across all previous versions of pangolin used to classify PHO sequences. The initial sample lineage assignment is compared to the most updated version of pangolin used when this report was generated. As such this visualization is a *simplification of the lineage re-assignments*. As of the date of reporting **`r sum(dates_reassign$counts)`** PHO samples have had their initial lineage designation reassigned. \

The current Pangolin version is: **v`r unique(sort(meta.data$pangolin_version_all, decreasing=T))[1]`**

*Note that for visual clarity the figure below displays combinations of initial and current lineage assignments with two or more samples. Single samples that were re-assigned lineages are not displayed below.* \


```{r, echo=F, warning=F, message=F, fig.height=24, fig.width=12}
library(networkD3)
library(stringr)

# Sankey network for lineage reassignment

dates_reassign <- dates_reassign %>% filter(counts > 1)

stream_frame <- data.frame(source = str_trim(str_split_fixed(dates_reassign$reassign, "->", 2)[,1]),
                           target = str_trim(str_split_fixed(dates_reassign$reassign, "->", 2)[,2]),
                           value = dates_reassign$counts)

nodes <- data.frame(
  name=c(as.character(stream_frame$source), 
         as.character(stream_frame$target)) %>% unique())

stream_frame$IDsource <- match(stream_frame$source, nodes$name)-1 
stream_frame$IDtarget <- match(stream_frame$target, nodes$name)-1

p <- sankeyNetwork(Links = stream_frame, Nodes = nodes,
                   Source = "IDsource", Target = "IDtarget",
                   Value = "value", NodeID = "name", 
                   sinksRight=FALSE, fontSize = 12,
                   iterations = 60)
p

```

