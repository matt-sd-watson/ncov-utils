---
title: "SARS-CoV-2 Genomic Surveillance"
subtitle: "Internal Report<div style=\"height: 40px;\"></div>" 

# Establish period for one week to day of execution
#date: "Updated:  `r format(Sys.time(), '%B %d, %Y')`"
# allow for date range that is previous week based on multiplying days by hours by seconds
# "Period: `r format(Sys.time() - 7*24*3600, '%B %d, %Y')` to `r format(Sys.time(), '%B %d, %Y')`"
mainfont: Arial
fontsize: 11
link-citations: yes
urlcolor:  #5E3B76
linkcolor: #5E3B76
citecolor: #5E3B76

output:
  html_document:
    toc: yes
    toc_float: no
    toc_depth: 4
    number_sections: no
    theme: readable
  pdf_document:
    toc: yes
    toc_depth: '4'
    includes:
      in_header: header.tex
toc-title: "Contents"

---

 <style type="text/css">
 .title {
  font-size: 38px;
  color: #4A4A4A;
  margin-top: 84px;
}
 .subtitle {
  font-size: 24px;
  color: #4A4A4A;
}
.author {  
  font-size: 24px;
  color: #4A4A4A;
}
.date {  
  font-size: 14px;
  color: #4A4A4A;
}
  h1 { /* Header 1 */
  font-size: 20pt;
  color: #4A4A4A;
}
h2 { /* Header 2 */
    font-size: 14pt;
  color: #4A4A4A;
}
body { /* Normal */
    font-size: 12pt;
    font-family: "Arial"; 
  color: black;
}
td { /* Table */
    font-size: 12pt;
    font-family: "Arial"; 
    color: black;
}
table th {
     background-color: #595959;
    /* sets table header cell background colour */
    }
TOC a {
 color: #5E3B76;
     font-size: 11pt;
 }
a {
  color: #5E3B76;
}

.figure {
   margin-top: 1px;
   margin-bottom: 1px;
}

</style>



```{r, echo=FALSE, out.width = "100px"}
htmltools::img(src = knitr::image_uri(file.path("./2_Input/PHO_Signature_en.svg")), 
               alt = 'logo', 
               style = 'position:absolute; top:20px; left:15px; padding:5px;')
```
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(data.table)
library(ggrepel)
library(lubridate)
library(viridis)
library(gridExtra)
library(wesanderson)
library(RColorBrewer)
library(directlabels)
library(argparse)
library(ggpubr)
library(gridExtra)
library(waffle)
library(magrittr)
library(hrbrthemes)
library(plotly)
library(knitr)
library(tidyverse)
library(lubridate)
#install.packages("https://cran.r-project.org/src/contrib/Archive/EpiWeek/EpiWeek_1.1.tar.gz", 
#                 repos = NULL, type="source")
library(EpiWeek)
library(paletteer)
library('unikn')
library(lemon)
library(treemapify)
library(colorspace)  # install via: install.packages("colorspace", repos = "http://R-Forge.R-project.org")
library(scales)
library(ggtree)
library(ape)
library(DT)
library(htmlwidgets)
library(gtable)
library(kableExtra)
library(grid)
library(lemon)
```
\
<p> </p>
_________________

<br></br>

# Background

Information is current as of **`r format(Sys.Date(), "%B %e, %Y")`**. This report summarizes analysis of SARS-CoV-2 samples with whole genome sequencing at Public Health Ontario (PHO) Laboratory. Each report provides an initial count of all sequenced samples and the remaining analyses focus on 2021 samples.
<p> </p>

PHO Laboratory performs whole genome sequencing (WGS) on a selection of SARS-CoV-2 samples submitted for primary diagnostic testing or specific PCR testing for Variants of Concern (VOC). Therefore, it is important to note that the numbers reported here do not represent all SARS-CoV-2 in Ontario. Furthermore, there is currently a bias towards sequencing of samples for which mutations present in VOCs have been detected.
<p> </p>

```{r VOC and VOI lists, include = FALSE}

# ---->>>> List of VOCs <<<<----
voc.list <- c("B.1.1.7", "B.1.351", "P.1")  # Add B.1.1.7 with E484K ?

# ---->>>> List of VOIs <<<<----
voi.list <- c("P.2", "P.3", "A.23.1 with E484K", "B.1.2 with E484K",
              "R.1", "B.1.1.318", "B.1.427", "B.1.429", "B.1.525", "B.1.526", "B.1.526.1",
              "B.1.617", "B.1.617.1", "B.1.617.2", "B.1.617.3", "B.1.618")

```



```{r data cleaning, include = FALSE}

#---- Import dataset ----
# meta.data <- list.files("/home/mwatson/COVID-19/qc50/", pattern = "*.csv")
# 

# Import data
meta.list<- list.files("./2_Input/", pattern = "export*|qc50*|qc90*")
meta.data <- read.csv(paste("./2_Input/", meta.list, sep=""), header = TRUE, na.strings=c("","NA"), stringsAsFactors=FALSE)


# Subset to include only processed results
# Filter to remove records without a login date
# Ensure distinct records
meta.df <- meta.data %>%
             filter(!is.na(Login_Date)) %>%
             filter(Processed_results == "Y") %>%
             filter(Exclude_from_analysis == "N" | is.na(Exclude_from_analysis)) %>%
             distinct()
  

# qc_data$date <- as.Date(qc_data$Login_Date, format = "%d%b%Y")
# 
# qc_data <- qc_data[!is.na(qc_data$date),]
# 
# # arrange by ascending date and remove all duplicate sample names to keep earliest database instance
# qc_data <- qc_data %>% arrange(date)
# 
# qc_data <- qc_data[!duplicated(qc_data$WGS_Id),]
# 
# qc_data_recent <- subset(qc_data, date >= "2021-01-01")



# ---- Clean up and Derive variables ----
meta.df.1 <- meta.df %>%
                mutate(Login.Date = as.Date(Login_Date, format =  "%d%b%Y")) %>%
                mutate(epi.wk.login = ifelse(is.na(Login.Date), NA,
                                             paste(epiyear(Login.Date), 
                                             sprintf( "%02d", epiweek(Login.Date)), sep = "-"))) %>%
                mutate(lineage.all = ifelse(lineage_all == "B.1.2" & E484K == "Detected", "B.1.2 with E484K",
                                     ifelse(lineage_all == "B.1.1.7" & E484K == "Detected", "B.1.1.7 with E484K",
                             	       ifelse(lineage_all == "A.23.1" & E484K == "Detected", 
                             	             "A.23.1 with E484K", lineage_all)))) %>%
                mutate(lineage.all.cat = ifelse(lineage.all %in% voc.list, "VoC",
                                         ifelse(lineage.all %in% voi.list, "VoI", "Other"))) %>%
                mutate(lin.parent.grp = gsub("\\..*","",lineage.all)) %>%
  
                mutate(upload.date.lineage.plate = 
                       as.Date(upload_date_lineage_plate, format =  "%m/%d/%Y")) %>%  
                mutate(epi.wk.compl = epiweek(upload.date.lineage.plate))



# ---- Define previous epi week dates ----
prev.epiwk <- epiweekToDate(as.numeric(format(Sys.Date(), "%Y")), epiweek(Sys.Date())-1, firstday = "Sunday")

prev.epiwk.start <- format(prev.epiwk$d0, "%B %e, %Y")
prev.epiwk.end <- format(prev.epiwk$d1, "%B %e, %Y")


# ---- Define epi week dates: 3 weeks prior ----
prev3.epiwk <- epiweekToDate(as.numeric(format(Sys.Date(), "%Y")), epiweek(Sys.Date())-3, firstday = "Sunday")

prev3.epiwk.start <- format(prev3.epiwk$d0, "%B %e, %Y")
prev3.epiwk.end <- format(prev3.epiwk$d1, "%B %e, %Y")


# ---- Filter to include only 2021 ----
meta.df.recent <- meta.df.1 %>% 
                    filter(Login.Date >= "2021-01-01")
 



```

```{r nextclade import, include = FALSE}
# read in the Nextclade data that has the mutation profiles
# make sure that the nextclade data is taken from the qc50 sequences and not all
#nextclade_loc <- list.files("/NetDrive/Projects/COVID-19/Other/master_fasta/", pattern = "nextclade*")
#nextclade_data <- read.table(paste("/NetDrive/Projects/COVID-19/Other/master_fasta/", nextclade_loc, sep=""), header = T, #sep = '\t', fill = TRUE, quote = "")

nextclade_loc <- list.files("./2_Input/", pattern = "nextclade*")
nextclade_data <-read.table(paste("./2_Input/", nextclade_loc, sep=""), header = T, sep = '\t', fill = TRUE, quote = "") 

```

```{r, include = FALSE}

# ----+ Prepare date for PHU pie charts +----
total_lin_counts <- subset(meta.df.recent, lineage.all %in% voc.list) %>%
                      arrange(Login.Date) %>%
                      group_by(lineage.all) %>% 
                      dplyr::summarise(total = n())

subset_lineages <- subset(meta.df.recent, lineage.all %in% voc.list & lineage.all != "None") %>%
                      arrange(Login.Date) %>%
                      group_by(lineage.all, HEALTH_UNIT_REPORTABLE) %>% 
                      dplyr::summarise(lin_counts = n())

merged <- merge(subset_lineages, total_lin_counts, by.x = "lineage.all", by.y = "lineage.all")
merged$percent <- round(100*(merged$lin_counts/merged$total), 2)
merged$new_name <- paste(merged$lineage.all, " ", "(", merged$total, ")", sep="")
merged$region_counts <- paste(merged$HEALTH_UNIT_REPORTABLE, " ", "(", merged$lin_counts, ")", sep="")

labels_over_2.5 <- subset(merged, percent >= 2.5)

for (i in unique(merged$lineage.all)) {
  subset <- subset(merged, lineage.all == i)
  title_name <- unique(subset$new_name)
  plot_name <- paste("pie_chart", i, sep="_")
  plot <- plot_ly(subset, labels = ~ region_counts, values = ~percent, type = 'pie',
                  textposition = 'inside',textinfo = 'label+percent',
                  textfont = list(color= c("white"), size = 15)) %>%
    layout(title = title_name,
           xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
           yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
           showlegend = T, colorway = c('rgba(114,147,203,1)',  'rgba(128,133,133,1)',
                                        'rgba(211,94,96,1)',
                                        'rgba(144,103,167,1)', 'rgba(171,104,87,1)'),
           showlegend = T)
  # on render function allows for clicking on legend entries to isolate in pie chart
  plot_animated <- ggplotly(plot) %>% onRender("function(el,x){el.on('plotly_legendclick', function(){ x.returnValue = false; })}")
  assign(plot_name, plot_animated)
}
```
\

```{r, echo = FALSE, include=FALSE}

# ----+ Total Number of Genomes +----
# Change from last reported (assume reporting every Wednesday)
time_cat_table <- meta.df.1 %>%
                    mutate(time_cat = ifelse(Login.Date >= prev.epiwk$d0 & 
                                             Login.Date <= prev.epiwk$d1, 
                                             "Change in genomes", "Total genomes")) %>%
                    mutate(time_cat = factor(time_cat, 
                                      levels = c("Change in genomes", "Total genomes"))) %>%
                    group_by(time_cat, .drop=FALSE) %>%
                    summarise(n = format(n(), nsmall=1, big.mark=",")) %>%
                    spread(time_cat, n)


# Change in last 3 weeks
time_cat_table.3wks <- meta.df.1 %>%
                    mutate(time_cat = ifelse(Login.Date >= prev3.epiwk$d0 & 
                                             Login.Date <= prev3.epiwk$d1, 
                                             "Change in genomes", "Total genomes")) %>%
                    mutate(time_cat = factor(time_cat, 
                                      levels = c("Change in genomes", "Total genomes"))) %>%
                    group_by(time_cat, .drop=FALSE) %>%
                    summarise(n = format(n(), nsmall=1, big.mark=",")) %>%
                    spread(time_cat, n)



# ----+ Total number of lineages by Year +----
num.lineages.yr <- meta.df.1 %>%  
                    filter(lineage.all != "None" & 
                             !is.na(lineage.all)) %>%   ##Why passes QC and doesn't have lineage?? Check!
                    mutate(login.yr = format(Login.Date, "%Y")) %>%
                    distinct(lineage.all, login.yr) %>%
                    group_by(login.yr, lineage.all) %>%
                    dplyr::summarise(n = n()) %>%
                    ungroup() %>%
                    group_by(login.yr) %>%
                    summarise(n.lin.yr = n()) %>%
                    spread(login.yr, n.lin.yr)



num_lineages <- data.frame(Category = paste("Number of unique Pango lineages", sep=""),
                                           # "(January 1, 2021 - ", 
                                          #  format(Sys.time(), "%B %d, %Y"), ")", sep=""),
                           Number = length(unique(meta.df.recent$lineage.all)))


# number of palettes needed
n.lin.parent <- meta.df.recent %>%
                filter(lineage.all != "None" & !is.na(lineage.all)) %>%
                distinct(lin.parent.grp) %>%
                summarise(n = n())

n.lin.grp <- meta.df.recent %>% 
              filter(lineage.all != "None" & !is.na(lineage.all)) %>%
              group_by(lin.parent.grp, lineage.all) %>%
              dplyr::summarise(n = n()) %>%
              ungroup()

# remove any that do not have a parent lineage
# n.lin.grp <- n.lin.grp[n.lin.grp$`Parent Lineage Group` != "",]

# Use 9 palettes from the colorspace package, one for each parent lineage
palette <- c( "Purp", "Greens", "Purples", "Mint","Teal", "PinkYl","PuRd","Burg", "RedOr")

n.lin.grp.cols <- n.lin.grp %>% 
                    distinct(lin.parent.grp) %>%
                    bind_cols(palette = palette) %>%
                    right_join(., n.lin.grp, by = "lin.parent.grp")


# Lineages will have a gradient that resets between parent lineages
meta.df.recent.col <- n.lin.grp.cols %>%
                        arrange(lin.parent.grp) %>% 
                        group_by(lin.parent.grp) %>%
                        mutate(colour = colorspace::sequential_hcl(length(lineage.all)+1, 
                               palette = palette)[seq_along(lineage.all)])

# Generate plot
pl.lin <- ggplot(meta.df.recent.col, aes(area = n, label = lineage.all, 
                                      fill = colour, subgroup = lin.parent.grp)) + 
            geom_treemap() + 
            geom_treemap_subgroup_border(color = "white") +
            geom_treemap_text(colour = "white", place = "topleft", reflow = T, min.size = 5) +
            #geom_treemap_subgroup_text(alpha = 1, grow = F, place = "center", color = "white") + 
            #geom_treemap_subgroup2_text(alpha = 0.7, grow = T, place = "center") + 
            theme(legend.position="none") + 
            scale_fill_identity()

# Lineage statistics for table
n.lin.grp <- meta.df.recent %>% 
              filter(!is.na(lineage.all) & 
                       lineage.all != "None") %>%   ##Why passes QC and doesn't have lineage?? Check!
              group_by(lineage.all) %>%
              dplyr::summarise(n = n()) %>%
              mutate(rel.freq = round(100*(n/sum(n)),2)) %>%
              ungroup() %>%
              left_join(., dplyr::select(meta.df.recent, lineage.all, 
                                         lineage.all.cat) 
                        %>% distinct(),
                        by = "lineage.all") %>%
              mutate(lineage.all.cat = ifelse(lineage.all.cat == "Other", "", lineage.all.cat)) %>%
              select(`Pango Lineage` = lineage.all, `Counts` = n, 
                     `Percentage` =rel.freq, Category = lineage.all.cat) %>%
              arrange(desc(Counts))


```

_________________

<br>

# Sequencing Summary

The number of genome sequences are summarized below and categorized by the total number as of `r prev.epiwk.end` and the number of genomes sequenced with a sample login date in the *previous three weeks*
(`r prev3.epiwk.start` - `r prev.epiwk.end`).

```{r, fig.width = 4, fig.height = 1.75, echo=F, warning=F, message=F, fig.keep = 'last'}

ggplot(data.frame(Total = c("A", "A"), Recent = c(0, 1)),
       aes(y = Total, x = Recent)) +
  geom_tile(color = "white", fill = "#F7F7F7", size = 8) +  
  annotate(geom="text", x=0, y=1.25, label="Change in genomes",
           color="#4B8184", size = 4) +
  annotate(geom="text", x=0, y=1, label=time_cat_table.3wks$`Change in genomes`,
           color="#4B8184", size = 10, fontface = 'bold') +
  annotate(geom="text", x=1, y=1.25, label="Total genomes",
           color="#4B8184", size = 4) +
  annotate(geom="text", x=1, y=1, label=time_cat_table.3wks$`Total genomes`,
           color="#4B8184", size = 10, fontface = 'bold') +
  theme_void() +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_discrete(expand = c(0,0)) 


```


```{r, results='asis', echo=FALSE}

#<div align="left">
# kable(as.data.frame(time_cat_table)) %>%
#   kable_styling(full_width = F))  %>%
#   row_spec(0:1, color = "#4B8184", background = "#FCFCFC", align = "c")

#</div>
```

<br>

## Number of Genomes by Sample Login Date

\

```{r, echo = FALSE, include=FALSE}

# ----+ Prepare data for bar plots, incl ALL weeks, autoscale +----

# Create a dataframe of 2020 only
meta.df.prev <- meta.df.1 %>%
                  filter(Login.Date <= "2020-12-31") %>%
                  distinct(Login.Date)
  
# Generate a list of epi weeks to-date 
epiwk.list.2020 <- paste("2020", sprintf("%02d", seq(min(epiweek(meta.df.prev$Login.Date)),
                                                     max(epiweek(meta.df.prev$Login.Date)), by = 1)), sep = "-")
epiwk.list.2021 <- paste(format(Sys.Date(), "%Y"), sprintf("%02d", seq(1, epiweek(Sys.Date())-1, by = 1)), sep = "-")
epiwk.list.all <- c(epiwk.list.2020, epiwk.list.2021)
epiwk.list.all.df <- data.frame(epiwk.list.all)

                
# identify most recent epiweek
end.epi.wk <- max(epiwk.list.all)

# Create a dataframe that completes all weeks (including those that have zero genomes)
meta.df.all.wks <- meta.df.1 %>% 
                    right_join(., epiwk.list.all.df, by = c("epi.wk.login" = "epiwk.list.all")) %>% 
                    select(WGS_Id, epi.wk.login, lineage.all, lineage.all.cat)

# Make a preliminary plot to extract autoscales
pl.n <- meta.df.all.wks %>% 
            ggplot() +
            geom_bar(aes(x=epi.wk.login)) +
            scale_y_continuous("Number of genomes", expand = c(0,10))


# Extract automatic scale
y.labs <- ggplot_build(pl.n)$layout$panel_params[[1]]$y$get_labels()
y.labs.intv <- y.labs %>%
                as.data.frame() %>%
                mutate(max.lab = max(as.numeric(.))) %>%
                mutate(intv=max.lab/(n()-1)) %>%
                distinct(intv) 
   
y.labs.scale <- y.labs %>%
                as.data.frame() %>%
                rename(intv = ".") %>%
                mutate(intv = as.numeric(intv)) %>%
                add_row(intv = y.labs.intv$intv + max(.$intv))%>%
                pull() 


```


```{r, echo=F, message=F, warning=F, fig.width=16, fig.height=10}

#---- Weekly Sequencing Summary Barplot ----

## create barplot of sequences, filtered to those with genome coverage >90%, epiweek login date in 2020 # Need to change this not include the completeness and just use database reported/processed
meta.df.all.wks %>% ggplot() +
                       geom_rect(aes(xmin = which(epiwk.list.all==end.epi.wk)-7.5,
                       xmax = which(epiwk.list.all==end.epi.wk)+0.5,
                       ymin=-Inf, ymax=Inf),
                       fill="grey90") + 
                       annotate("text", x = which(epiwk.list.all==end.epi.wk)-7.45, 
                                                    y = Inf, 
                                        label = "Subject to \nsequencing lag",
                                        size = 5, vjust = 1.2, hjust = -.03, color = "black") +
                      theme(plot.tag.position = c(0.96, 0.9)) +
                      geom_bar(aes(x=epi.wk.login)) +
                      theme(axis.text.x = element_text(angle = 90, size = 16, vjust = 0.5),
                            axis.text.y = element_text(size = 16),
                            axis.title.x = element_text(size = 16, margin = margin(t = 20, r = 0, b = 0, l = 0)),
                            axis.title.y = element_text(size = 16),
                            plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
                            panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                            panel.background = element_blank(), axis.line = element_line(colour = "black"),
                            legend.position = c(0.87, 0.75),
                            legend.title = element_text(size = 16),
                            legend.text = element_text(size = 14)) +
                      labs(fill = "Category") + xlab("Epidemiological week") + ylab("Sample Counts") +
                      coord_capped_cart(left='both', bottom = 'both') +
                      scale_x_discrete("Epidemiological week") +
                      scale_y_continuous("No. genomes", breaks = seq(0, round(max(as.numeric(y.labs)), -2) + 2000, 100),
                       limits = c(0, round(max(as.numeric(y.labs)), -2) + 200))
                  


```
  
```{r, echo=F, message=F, warning=F, fig.width=13, include=FALSE}
## THIS CODE CORERSPONDS TO THE SEQUENCING SUMMARY FOR 2020. It has been parked for now. 
### SARAH SECTION 2 - Weekly Sequencing Summary ---- ###

## load packages

library(lemon)

## create barplot of sequences, filtered to those with genome coverage >90%, epiweek login date in 2020

# meta.df$genome_completeness <- as.numeric(meta.df$genome_completeness)
# 
#   ggplot(data=subset(meta.df, genome_completeness >= 0.9 & epi.wk.login < '2021-01')) +
#     geom_bar(aes(x=epi.wk.login)) +
#     theme(axis.text.x = element_text(angle = 90, size = 14),
#           axis.text.y = element_text(size = 14),
#           axis.title.x = element_text(size = 14, margin = margin(t = 20, r = 0, b = 0, l = 0)),
#           axis.title.y = element_text(size = 14),
#           plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#           panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#           panel.background = element_blank(), axis.line = element_line(colour = "black"),
#           legend.position = c(0.87, 0.75),
#           legend.title = element_text(size = 14),
#           legend.text = element_text(size = 12)) +
#     labs(fill = "Category") + xlab("Epidemiological week") + ylab("Sample Counts") +
#     coord_capped_cart(left='both', bottom = 'both') +
#     scale_y_continuous("Number of genomes", expand = c(0,10)) 
```


```{r, include=FALSE}
#placeholder
```


```{r, echo=F, message=F, warning=F, fig.width=13, fig.height=9, include=FALSE}
# THIS CODE CORRESPONDS TO SEQUENCING SUMAMRIES FOR 2021. It has been parked for now
## sarah code part II
## get the start and end points for highlighted regions

# start point = 3 weeks before most recent login date

#start <- (max(meta.df$Login.Date) - 21)

# convert to epiweek

#start.epi.wk <- paste(epiyear(start), sprintf( "%02d", epiweek(start)), sep = "-")

# end point = most recent login date
#end <- max(meta.df$Login.Date)

# convert to epiweek

#end.epi.wk <- paste(epiyear(end), sprintf( "%02d", epiweek(end)), sep = "-")
  

# create rectangle frame to call for figure
#rect <- data.frame(xmin= (start.epi.wk), xmax= (end.epi.wk), ymin=-Inf, ymax=Inf)
  
## create barplot of sequences, filtered to those with genome coverage >90%, epiweek login date in 2021 (eg ignore 2020-53)

# ggplot(data=subset(meta.df, genome_completeness >= 0.9 & epi.wk.login >= '2021-01')) +
#   geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
#               color="grey20",
#               alpha=0.25,
#               inherit.aes = FALSE) +
# 
#     geom_text(data=rect, aes(x = xmin, y = ymax,
#     label = "Samples recieved during this\ntime period may not yet\nbe sequenced"),
#              size = 4, vjust = 1.2, hjust = -0.03, color = "black") +
# 
#     geom_bar(aes(x=epi.wk.login)) +
# 
#     theme(axis.text.x = element_text(angle = 90, size = 14),
#           axis.text.y = element_text(size = 14),
#           axis.title.x = element_text(size = 14, margin = margin(t = 20, r = 0, b = 0, l = 0)),
#           axis.title.y = element_text(size = 14),
#           plot.margin = unit(c(0, 0, 1.5, 0), "cm"),
#           panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#           panel.background = element_blank(), axis.line = element_line(colour = "black"),
#           legend.position = c(0.87, 0.75),
#           legend.title = element_text(size = 14),
#           legend.text = element_text(size = 12)) +
#     labs(fill = "Category") + xlab("Epidemiological week") + ylab("Sample Counts") +
#     coord_capped_cart(left='both', bottom = 'both') +
#     scale_y_continuous("Number of genomes", expand = c(0,10)) 
```

\
<p> </p>
_________________

<br>

# Pango Lineages

As part of PHOâ€™s bioinformatic processing, all genomic sequences are routinely analyzed using the pangolin tool (https://cov-lineages.org/index.html) and receive a Pango lineage designation. The dynamic Pango nomenclature system allows for the classification of SARS-CoV-2 genetic diversity. Reassignments of Pango lineages are expected to occur as more SARS-CoV-2 genome sequences become available, thus providing a more complete picture of SAS-CoV-2 evolution and more accurate lineage assignment.
\
\

## Pango Lineages by Year
```{r, fig.width = 4, fig.height = 1.75, echo=F, warning=F, message=F, fig.keep = 'last'}

ggplot(data.frame(Total = c("A", "A"), Recent = c(0, 1)),
       aes(y = Total, x = Recent)) +
  geom_tile(color = "white", fill = "#F7F7F7", size = 8) +  
  annotate(geom="text", x=0, y=1.25, label="Unique Lineages, 2020",
           color="#4B8184", size = 4) +
  annotate(geom="text", x=0, y=1, label=num.lineages.yr$`2020`,
           color="#4B8184", size = 10, fontface = 'bold') +
  annotate(geom="text", x=1, y=1.25, label="Unique Lineages, 2021",
           color="#4B8184", size = 4) +
  annotate(geom="text", x=1, y=1, label=num.lineages.yr$`2021`,
           color="#4B8184", size = 10, fontface = 'bold') +
  theme_void() +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_discrete(expand = c(0,0)) 
```


```{r, results='asis', echo=FALSE}
#kable(as.data.frame(num_lineages))
 # kable(as.data.frame(num_lineages)) %>%
 #   kable_styling(full_width = F)  %>%
 #   row_spec(0, color = "white", background = "#4A4A4A", align = "c")
```
\
```{r, include=FALSE}

```
## Frequency of Pango lineages

Pango lineages from sequenced samples (January 1, 2021 - `r prev.epiwk.end`). The plot is divided into tiles, each of which represents a single lineage. The relative area of each tile represents the number of sequenced genomes assigned to each lineage.

```{r, echo=FALSE, fig.height=7, fig.width=8}
pl.lin
```
\
\
\
```{r, include=F}
# placeholder
```

<br>

## Pango Lineage Frequency, January 1, 2021 - `r prev.epiwk.end`
\
```{r, results='asis', echo=FALSE}

datatable(as.data.frame(n.lin.grp), #extensions = 'Buttons',
          options = list(pageLength = 10, #dom = 'Bfrtip', #buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                   columnDefs = list(list(className = 'dt-left', targets = 1:3),
                                     list(className = 'dt-center', targets = 4)),
                   autowidth = TRUE,initComplete = JS(
                            "function(settings, json) {",
                            "$(this.api().table().header()).css({'color': 'white'});",
                            "}"))) 
                   
                 #  columnDefs = list(list(className = 'dt-left', targets = '_all'))))

#kable(as.data.frame(num_lineages))
 # kable(as.data.frame(num_lineages)) %>%
 #   kable_styling(full_width = F)  %>%
 #   row_spec(0, color = "white", background = "#4A4A4A", align = "c")
```
\
\

## Lineage Categories by Epidemiological Week 

<p> </p>

Details of the Pango lineage categories can be found in the [Technical Notes](#technical-notes). 

\
```{r, r, echo=F, message=F, warning=F, fig.width=16, fig.height=10}


# ---- VOC/VOIs by Epi week barplot ----

# The y-axis is autoscaled based on code 
meta.df.all.wks %>% 
        group_by(epi.wk.login, lineage.all.cat) %>%
        dplyr::summarise(n = n()) %>%
          ggplot(aes(x = epi.wk.login, y = n, fill = lineage.all.cat)) +
             geom_rect(aes(xmin = which(epiwk.list.all==end.epi.wk)-7.5,
                                 xmax = which(epiwk.list.all==end.epi.wk)+0.5,
                                 ymin=-Inf, ymax=Inf),
                                 fill="grey90") + 
                                 annotate("text", x = which(epiwk.list.all==end.epi.wk)-7.45, y = Inf, 
                                                  label = "Subject to \nsequencing lag",
                                                  size = 5, vjust = 1.2, hjust = -.03, color = "black") +
              geom_bar(stat = "identity") +
                  theme(panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.background = element_blank(),
                        plot.margin = unit(c(5,0,0,0), "lines"),
                        axis.line = element_line(color="black"),
                        legend.text=element_text(size=18),
                        legend.title=element_text(size=18, face = "bold"),
                        legend.position=c(0.1, 0.9),
                        legend.box = "vertical",
                        legend.box.margin = margin(0.05,0.05,0.05,0.05,"cm"),
                        legend.box.background = element_rect(colour = "black"),
                        legend.spacing.y = unit(0.3, "cm"),
                        legend.key.width = unit(0.6, "cm"),
                        legend.key.height = unit(0.3, "cm"),
                        axis.text.y = element_text(size = 18),
                        axis.text.x = element_text(size = 18, angle = 90, hjust = 1, vjust = 0.5),
                        axis.title.y = element_text(size = 18),
                        axis.title.x = element_text(size = 18, margin = margin(t = 20, r = 0, b = 0, l = 0)),
                        legend.spacing.x = unit(0.3, 'cm')) +
                scale_fill_manual("Lineage Category",
                                values = c("VoC" = "#4B91A5", "VoI" = "#D4999A",
                                           "Other" = "#621C4E", "None" = "#B7B7B7"), 
                                breaks = c("VoC", "VoI", "Other", "None")) +
                                      scale_y_continuous("Number of genomes", breaks = seq(0, round(max(as.numeric(y.labs)), -2) + 2000, 100),
                       limits = c(0, round(max(as.numeric(y.labs)), -2) + 200)) +
                scale_x_discrete("Epidemiological week", expand = c(0,0.5)) + 
                coord_capped_cart(left='both', bottom = 'right')

```
\
\
```{r, include=F}
# placeholder
```

***

\

# Variants of Concern (VoC)

Cumulative counts of genome sequences for each lineage designated as a VoC (January 1, 2021 - `r prev.epiwk.end`).\
A list of the current Pango lineages classified as a VoC can be found in the [Technical Notes](#technical-notes). 

<p> </p>

*Note: Interpret with caution as there have been several changes in sequencing strategies over this time period.*

```{r, include = FALSE, echo=FALSE}


# Create a dataframe for 2021
epiwk.list.2021.df <- data.frame(epiwk.list.2021)


# Create a dataframe that completes all weeks (including those that have zero genomes)
meta.df.all.2021.wks <- meta.df.recent %>% 
                          right_join(., epiwk.list.2021.df, 
                                     by = c("epi.wk.login" = "epiwk.list.2021")) %>% 
                          select(WGS_Id, epi.wk.2021.login = epi.wk.login, lineage.all)


# Count VOCs by login date
subset.voc.date <- meta.df.all.2021.wks %>%
                    filter(!is.na(lineage.all) & lineage.all != "None") %>%
                    filter(lineage.all %in% voc.list) %>%
                      arrange(epi.wk.2021.login) %>%
                      group_by(lineage.all, epi.wk.2021.login) %>% 
                      dplyr::summarise(lin.counts = n())

# Create cumulative count of VOCs by login date
rolling.cases <- subset.voc.date %>% 
                  group_by(lineage.all, .drop = FALSE) %>%
                  mutate(cumcases = cumsum(lin.counts)) %>%
                  dplyr::select(lineage = lineage.all, epi.wk.2021.login, lin.counts, cumcases) %>%
                  mutate(lineage = factor(lineage, levels=c("P.1","B.1.351", "B.1.1.7")))


# Calculate where to put the sequencing lag label
# txt.pl <- rolling.cases %>%
#            group_by(lineage, .drop = FALSE) %>%
#             mutate(txt = max(cumcases)/5) %>%
#             distinct(lineage, txt)


# colour palette for VOCs
voc.pal <- c("B.1.1.7" = "#4B91A5",
             "B.1.351" = "#76B5BE",
             "P.1" = "#67223F")
  

# Create plot
plot.voc <- ggplot(rolling.cases, aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
              # facet wrap with as fable allows for blank cell in col 2 cell 1
              # https://stackoverflow.com/questions/56447366/ordering-placement-of-empty-facet-when-using-facet-wrap
              facet_rep_wrap(~lineage, ncol=1, scales = "free_y", as.table = F, 
                             repeat.tick.labels = 'bottom') +
              geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-7.5,
              xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
              ymin=-Inf, ymax=Inf),
              fill="grey90", colour = "grey90") +
              annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
                       y = Inf,
              label = "Subject to \nsequencing lag",
              size = 3, vjust = 10, hjust = -.03, color = "black") +
                #size = 3, vjust = 1.2, hjust = -.03, color = "black") +
              geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases, group = 1)) +
              geom_point(size = 3) +
              theme_bw() + 
              theme(axis.text.x = element_text(size = 10, angle = 90, hjust = 1, vjust = 0.5),
                                   axis.text.y = element_text(size = 10),
                                   #title = element_text(size = 16),
                                   axis.title.x = element_text(vjust=-0.5, size = 14),
                                   strip.text = element_text(size = 16, face="bold", hjust = 0),
                                   panel.spacing = unit(1.5, "lines"),
                                   panel.border = element_blank(), 
                                   axis.title.y = element_text(size = 10),
                                   plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
                                   legend.position = "none",
                                   panel.grid.major = element_blank(), 
                                   panel.grid.minor = element_blank(),
                                   panel.background = element_blank(), 
                                   axis.line = element_line(colour = "black"),
                      strip.background =element_rect(fill = NA, colour = NA)) +
                      scale_color_manual(values = c(voc.pal)) +
                      xlab("Login Date") +
                      ylab("Cumulative number of genomes") + 
                      scale_x_discrete("Epidemiological week", 
                                       expand = c(0,0.5), limits = epiwk.list.2021) + 
                      #scale_x_date(date_labels = "%b-%Y") +
                      coord_capped_cart(left='both', bottom = 'both') 
```
\
\
```{r, warning=FALSE, fig.height=12, fig.width=8, echo=FALSE}
plot.voc
```
\
\

***

<br> 
<br> 

## VOC Relative Frequency by Public Health Unit

\
\

```{r pressure, echo=FALSE, fig.width=8.5}
pie_chart_B.1.1.7
pie_chart_B.1.351
pie_chart_P.1
```



```{r, echo=FALSE, include = FALSE}

mutations <- c("S:N501Y", "S:E484K")

nextclade_qc50 <- nextclade_data[nextclade_data$seqName %in% meta.df.1$WGS_Id,]

# search for all mutations using grepl
nextclade_with_mut <- nextclade_qc50[grepl(paste(mutations,collapse="|"), 
                                           nextclade_qc50$aaSubstitutions),]

# remove any object matching pattern for concatenation
rm(list=ls(pattern="^mutation_frame.*"))

# create a mutation frame for each mutation with the samples containing the mutation
for (i in mutations) {
  nextclade_with_mut <- nextclade_qc50[grepl(i, nextclade_qc50$aaSubstitutions),]
  nextclade_with_mut$lineage <- i
  name <- paste("mutation_frame_", i, sep="")
  assign(name, nextclade_with_mut)
}

# bind all mutation frames
df_list <- mget(ls(pattern = "^mutation_frame.*"))
all_muts <- plyr::rbind.fill(df_list)

muts_frame_keep <- subset(all_muts, select = c(seqName, lineage))

mut_merged <- merge(meta.df.1, muts_frame_keep, by.x = "WGS_Id",
                    by.y = "seqName")

mut_lin_rolling_date <- subset(mut_merged, select = c(WGS_Id, lineage.all,
                                                      Login.Date, lineage))

colnames(mut_lin_rolling_date) <- c("name", "lineage", "date", "mutation")
print(mut_lin_rolling_date)
```

```{r, fig.width = 22, fig.height = 10, echo=F, message=F, warning=F, include=FALSE}

for (i in voc.list) {
  health_region_over_time <- subset(meta.df.recent, lineage.all == i) %>%
  group_by(epi.wk.login, HEALTH_UNIT_REPORTABLE) %>% dplyr::summarise(Samples = n())
  health_region_over_time$Cum <- cumsum(health_region_over_time$Samples)
  plot_name <- paste("health_unit_time", i, sep="_")
  p_unit <- ggplot(health_region_over_time, aes(x = epi.wk.login, y = Samples, fill =
                                           HEALTH_UNIT_REPORTABLE)) +
  geom_bar(stat = "identity") +
  theme_bw() + theme(axis.text.x = element_text(angle = 0, size = 16),
                     axis.text.y = element_text(size = 16),
                     title = element_text(size = 18),
                     axis.title.x = element_text(vjust=-0.5, size = 16),
                     strip.text = element_text(size = 14),
                     legend.title = element_text(size = 16),
        legend.text = element_text(size = 14),
        axis.title.y = element_text(size = 16),
        plot.title = element_text(size = 24),
        plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  xlab("Epidemiological week") + ggtitle(paste("Health Unit Distribution by epi week,", i, sep=" ")) +
    labs(fill = "Health Unit")
  assign(plot_name, p_unit)
}

health_unit_time_B.1.1.7

health_unit_time_B.1.351

health_unit_time_P.1


```


```{r, echo=FALSE, include = FALSE, message=FALSE}
mut_lin_date_grouped <- mut_lin_rolling_date %>% arrange(date) %>%
  group_by(mutation, lineage, date) %>%
  dplyr::summarise(counts = n())

mut_lin_date_grouped_final <- mut_lin_date_grouped %>% group_by(mutation, lineage) %>%
  mutate(cumcases = cumsum(counts))

# set 501 mutation to come before 484
mut_lin_date_grouped_final$mutation <- factor(mut_lin_date_grouped_final$mutation,
                                                 levels = c("S:N501Y", "S:E484K"))

mut_lin_date_grouped_final_voc <- mut_lin_date_grouped_final[mut_lin_date_grouped_final$lineage %in% c("P.1", "B.1.351"),]

# get the most recent date for each of the lineages by mutation
max_date_each_lin_voc <- mut_lin_date_grouped_final_voc %>% group_by(mutation, lineage) %>% filter(date == max(date))

# plot the lineages separately for each mutation
# include a label at the most recent date of logging for each mutation
plot_voc_no_b117 <- ggplot(mut_lin_date_grouped_final_voc, aes(x = date, y = cumcases, col = lineage)) +
  geom_point(data = max_date_each_lin_voc, aes(color = lineage)) +
  geom_line() + facet_wrap(~mutation, ncol = 2) + ylab("Case Counts") +
  xlab("Login Date") +
  theme(text = element_text(size=20),
        axis.title.x = element_text(vjust=-0.5),
        plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  geom_text_repel(data = max_date_each_lin_voc,
                  aes(label = paste(lineage, paste("(", cumcases, ")", sep = ""), sep = " ")), hjust = 0, nudge_x = 0.05, size = 5,
                  col = "black") +
  ggtitle("Cumulative Counts of VoC Lineages with Mutations of Interest, no B.1.1.7") +
  scale_x_date(date_labels = "%b-%Y")


mut_lin_date_grouped_final_non_voc <- mut_lin_date_grouped_final[!mut_lin_date_grouped_final$lineage %in% c("P.1", "B.1.351", "B.1.1.7"),]

# get the most recent date for each of the lineages by mutation
max_date_each_lin_non_voc <- mut_lin_date_grouped_final_non_voc %>% group_by(mutation, lineage) %>% filter(date == max(date))

# plot the lineages separately for each mutation
# include a label at the most recent date of logging for each mutation
plot_non_voc <- ggplot(mut_lin_date_grouped_final_non_voc, aes(x = date, y = cumcases, col = lineage)) +
  geom_point(data = max_date_each_lin_non_voc, aes(color = lineage)) +
  geom_line() + facet_wrap(~mutation, ncol = 2) + ylab("Case Counts") +
  xlab("Login Date") +
  theme(text = element_text(size=20),
        axis.title.x = element_text(vjust=-0.5),
        plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  geom_text_repel(data = max_date_each_lin_non_voc,
                  aes(label = paste(lineage, paste("(", cumcases, ")", sep = ""), sep = " ")), hjust = 0, nudge_x = 0.05, size = 5,
                  col = "black") +
  ggtitle("Cumulative Counts of non-VoC Lineages with Mutations of Interest") +
  scale_x_date(date_labels = "%b-%Y")

mut_lin_date_grouped_final_b117 <- mut_lin_date_grouped_final[mut_lin_date_grouped_final$lineage == "B.1.1.7",]

# get the most recent date for each of the lineages by mutation to assign labels
max_date_each_lin_b117 <- mut_lin_date_grouped_final_b117 %>% group_by(mutation, lineage) %>% filter(date == max(date))

plot_b117 <- ggplot(mut_lin_date_grouped_final_b117, aes(x = date, y = cumcases, col = lineage)) +
  geom_point(data = max_date_each_lin_b117, aes(color = lineage)) +
  geom_line() + facet_wrap(~mutation, ncol = 2) + ylab("Case Counts") +
  xlab("Login Date") +
  theme(text = element_text(size=20),
        axis.title.x = element_text(vjust=-0.5, size = 20),
        plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  geom_text_repel(data = max_date_each_lin_b117,
                  aes(label = paste(lineage, paste("(", cumcases, ")", sep = ""), sep = " ")), hjust = 0, nudge_x = 0.05, size = 5,
                  col = "black") +
  ggtitle("Cumulative Counts of Lineages with Mutations of Interest, B.1.1.7") +
  scale_x_date(date_labels = "%b-%Y")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=12.5, fig.width=17, include=F}
plot_b117
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=16, fig.width=17,include=F}
plot_voc_no_b117
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=12.5, fig.width=17, include=F}
plot_non_voc
```

# Variants of Interest (VoI)
\
A list of the current Pango lineages that are classified as VoIs by PHO can be found in the  [Technical Notes](#technical-notes). 

```{r, include = FALSE, echo=FALSE}


# subset._voi.date <- subset(meta.df.recent, lineage.all %in% voi.list & lineage.all != "None") %>%
#                     arrange(Login.Date) %>%
#                     group_by(lineage.all, Login.Date) %>% 
#                     dplyr::summarise(lin_counts = n())
# 
# rolling_cases_voi <- subset_voi_date %>% 
#                       group_by(lineage.all, .drop = FALSE) %>%
#                       mutate

# Count VOIs by login date
subset.voi.date <- meta.df.all.2021.wks %>%
                    filter(!is.na(lineage.all) & lineage.all != "None") %>%
                    filter(lineage.all %in% voi.list) %>%
                      arrange(epi.wk.2021.login) %>%
                      group_by(lineage.all, epi.wk.2021.login) %>% 
                      dplyr::summarise(lin.counts = n())

# Create cumulative count of VOCs by login date
rolling.cases.voi <- subset.voi.date %>% 
                      group_by(lineage.all, .drop = FALSE) %>%
                      mutate(cumcases = cumsum(lin.counts)) %>%
                      dplyr::select(lineage = lineage.all, epi.wk.2021.login, lin.counts, cumcases) %>%
                      mutate(lineage = factor(lineage, levels=c("B.1.1.318", "B.1.525", "B.1.526", "B.1.526.1",
                      "P.2", "P.3", "A.23.1 with E484K", 
                      "B.1.2 with E484K",
                      "R.1", "B.1.427", "B.1.429",
                      "B.1.617", "B.1.617.1", "B.1.617.2", "B.1.617.3", "B.1.618")))


#setnames(rolling.cases.voi, old = c('lineage.all'), new = c('lineage'))

# max_date_each_voi <- rolling.cases.voi %>% 
#                       group_by(lineage) %>% 
#                       filter(Login.Date == max(Login.Date))

# colour palette for VOIs
voi.pal <- c("#ff8c8a","#00c18e","#940295","#d49500", 
             "#0254cf","#765900","#7848ce","#f1bc81","#c3006c","#fcb69c","#ff89e1","#824025")

## get the start and end points for highlighted regions

  # start point = 3 weeks before most recent login date

# start.s5 <- (max(rolling.cases.voi$epi.wk.2021.login) - 6)
# 
#   # end point = most recent login date
# 
# end.s5 <- max(rolling.cases.voi$epi.wk.2021.login)
# 
#   # create rectangle frame to call for figure
# 
# rect.s5 <- data.frame(xmin= (start.s5), xmax= (end.s5), ymin=-Inf, ymax=Inf)

# set this specific order to place the blank cell next to b117 and have other 
# two vocs on separate line
rolling.cases.voi$lin.fac <- factor(rolling.cases.voi$lineage, 
                                    levels=c("P.2", "P.3", "B.1.525", 
                                             "R.1", "B.1.1.318", "B.1.427", "B.1.429", "B.1.526",
                                              "B.1.617", "B.1.617.1", "B.1.618", "B.1.617.2", "B.1.617.3"))


# plot_voi <- ggplot(rolling.cases.voi, aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
#               # facet wrap with as fable allows for blank cell in col 2 cell 1
#               # https://stackoverflow.com/questions/56447366/ordering-placement-of-empty-facet-when-using-facet-wrap
#               # facet_rep_wrap(~lineage, ncol=1, scales = "free_y", as.table = F, 
#               #                repeat.tick.labels = 'bottom') +
#               geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-7.5,
#               xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
#               ymin=-Inf, ymax=Inf),
#               fill="grey90", colour = "grey90") +
#               annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
#                        y = Inf,
#               label = "Subject to \nsequencing lag",
#               size = 3, vjust = 10, hjust = -.03, color = "black") +
#                 #size = 3, vjust = 1.2, hjust = -.03, color = "black") +
#               geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases)) +
#               geom_point(size = 3) +
#               theme_bw() + 
#               theme(axis.text.x = element_text(size = 10, angle = 90, hjust = 1, vjust = 0.5),
#                                    axis.text.y = element_text(size = 10),
#                                    #title = element_text(size = 16),
#                                    axis.title.x = element_text(vjust=-0.5, size = 14),
#                                    strip.text = element_text(size = 16, face="bold", hjust = 0),
#                                    panel.spacing = unit(1.5, "lines"),
#                                    panel.border = element_blank(), 
#                                    axis.title.y = element_text(size = 10),
#                                    plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#                                    legend.position = "left",
#                                    panel.grid.major = element_blank(), 
#                                    panel.grid.minor = element_blank(),
#                                    panel.background = element_blank(), 
#                                    axis.line = element_line(colour = "black"),
#                       strip.background =element_rect(fill = NA, colour = NA)) +
#                       scale_color_manual(values = c(voi.pal)) +
#                       xlab("Login Date") +
#                       ylab("Cumulative number of genomes") + 
#                       scale_x_discrete("Epidemiological week", 
#                                        expand = c(0,0.5), limits = epiwk.list.2021) + 
#                       #scale_x_date(date_labels = "%b-%Y") +
#                       coord_capped_cart(left='both', bottom = 'both') 

# ggplot(rolling.cases.voi, aes(x = epi.wk.2021.login, y = cumcases, color = lineage)) + 
#               # facet wrap with as fable allows for blank cell in col 2 cell 1
#               # https://stackoverflow.com/questions/56447366/ordering-placement-of-empty-facet-when-using-facet-wrap
#               # facet_rep_wrap(~lineage, ncol=1, scales = "free_y", as.table = F, 
#               #                repeat.tick.labels = 'bottom') +
#               geom_rect(aes(xmin = which(epiwk.list.2021==end.epi.wk)-7.5,
#               xmax = which(epiwk.list.2021==end.epi.wk)+0.5,
#               ymin=-Inf, ymax=Inf),
#               fill="grey90", colour = "grey90") +
#               annotate("text", x = which(epiwk.list.2021==end.epi.wk)-1.5,
#                        y = Inf,
#               label = "Subject to \nsequencing lag",
#               size = 3, vjust = 10, hjust = -.03, color = "black") +
#                 #size = 3, vjust = 1.2, hjust = -.03, color = "black") +
#               geom_line(color='black', aes(x = epi.wk.2021.login, y = cumcases)) +
#               geom_point(size = 3) +
#               theme_bw() + 
#               theme(axis.text.x = element_text(size = 10, angle = 90, hjust = 1, vjust = 0.5),
#                                    axis.text.y = element_text(size = 10),
#                                    #title = element_text(size = 16),
#                                    axis.title.x = element_text(vjust=-0.5, size = 14),
#                                    strip.text = element_text(size = 16, face="bold", hjust = 0),
#                                    panel.spacing = unit(1.5, "lines"),
#                                    panel.border = element_blank(), 
#                                    axis.title.y = element_text(size = 10),
#                                    plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#                                    legend.position = "left",
#                                    panel.grid.major = element_blank(), 
#                                    panel.grid.minor = element_blank(),
#                                    panel.background = element_blank(), 
#                                    axis.line = element_line(colour = "black"),
#                       strip.background =element_rect(fill = NA, colour = NA)) +
#                       scale_color_manual(values = c(voi.pal)) +
#                       xlab("Login Date") +
#                       ylab("Cumulative number of genomes") + 
#                       scale_x_discrete("Epidemiological week", 
#                                        expand = c(0,0.5), limits = epiwk.list.2021) + 
#                       #scale_x_date(date_labels = "%b-%Y") +
#                       coord_capped_cart(left='both', bottom = 'both') 


# Create a dataframe that completes all weeks (including those that have zero genomes)
# meta.df.all.wks <- meta.df.1 %>% 
#                     right_join(., epiwk.list.all.df, by = c("epi.wk.login" = "epiwk.list.all")) %>% 
#                     select(WGS_Id, epi.wk.login, lineage.all, lineage.all.cat)

# z<- meta.df.all.2021.wks %>% 
#         filter(lineage.all %in% voi.list) %>%
#         group_by(epi.wk.2021.login, lineage.all) %>%
#         dplyr::summarise(n = n()) %>%
#           ggplot(aes(x = epi.wk.login, y = n, fill = lineage.all)) +
#              # geom_rect(aes(xmin = which(epiwk.list.all==end.epi.wk)-7.5,
#              #                     xmax = which(epiwk.list.all==end.epi.wk)+0.5,
#              #                     ymin=-Inf, ymax=Inf),
#              #                     fill="grey90") + 
#              #                     annotate("text", x = which(epiwk.list.all==end.epi.wk)-7.45, y = Inf, 
#              #                                      label = "Subject to \nsequencing lag",
#              #                                      size = 5, vjust = 1.2, hjust = -.03, color = "black") +
#               geom_bar(stat = "identity") +
#                 #   theme(panel.grid.major = element_blank(),
#                 #         panel.grid.minor = element_blank(),
#                 #         panel.background = element_blank(),
#                 #         plot.margin = unit(c(5,0,0,0), "lines"),
#                 #         axis.line = element_line(color="black"),
#                 #         legend.text=element_text(size=18),
#                 #         legend.title=element_text(size=18, face = "bold"),
#                 #         legend.position=c(0.1, 0.9),
#                 #         legend.box = "vertical",
#                 #         legend.box.margin = margin(0.05,0.05,0.05,0.05,"cm"),
#                 #         legend.box.background = element_rect(colour = "black"),
#                 #         legend.spacing.y = unit(0.3, "cm"),
#                 #         legend.key.width = unit(0.6, "cm"),
#                 #         legend.key.height = unit(0.3, "cm"),
#                 #         axis.text.y = element_text(size = 18),
#                 #         axis.text.x = element_text(size = 18, angle = 90, hjust = 1, vjust = 0.5),
#                 #         axis.title.y = element_text(size = 18),
#                 #         axis.title.x = element_text(size = 18, margin = margin(t = 20, r = 0, b = 0, l = 0)),
#                 #         legend.spacing.x = unit(0.3, 'cm')) +
#                 # scale_fill_manual("Lineage Category",
#                 #                 values = voi.pal) +
#                 #                       scale_y_continuous("Number of genomes", expand = c(0,10), 
#                 #                                          limits = c(0, max(y.labs.scale)),     
#                 #                                          breaks = y.labs.scale, labels = y.labs.scale) +
#                 scale_x_discrete("Epidemiological week", expand = c(0,0.5)) + 
#                 coord_capped_cart(left='both', bottom = 'right')



# plot_voi <- ggplot(rolling.cases.voi, aes(x = Login.Date, y = cumcases, color = lin.fac)) +
#   geom_point(size = 3) + 
#   scale_color_manual(values = c(voi.pal)) +
#   # facet wrap with as fable allows for blank cell in col 2 cell 1
#   # https://stackoverflow.com/questions/56447366/ordering-placement-of-empty-facet-when-using-facet-wrap
#   #facet_wrap(~lin_fac, ncol=1, scales = "free_y", as.table = F) +
#   geom_rect(data=rect.s5, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
#                color="grey30",alpha=0.25, inherit.aes = FALSE) +
#   theme_bw() + theme(axis.text.x = element_text(angle = 0, size = 14),
#                        axis.text.y = element_text(size = 14),
#                        title = element_text(size = 16),
#                        axis.title.x = element_text(vjust=-0.5, size = 16),
#                        strip.text = element_text(size = 18),
#                        axis.title.y = element_text(size = 16),
#                        plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#           legend.position = "none",
#                        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#                        panel.background = element_blank(), axis.line = element_line(colour = "black"),
#           strip.background =element_rect(fill="white")) +
#    geom_line(color='black',data = rolling.cases.voi, aes(x = date, y = cumcases)) +
#      geom_text(data=rect.s5, aes(x = xmin, y = ymin, 
#                                  label = "Samples recieved \nduring this time period\nmay not yet be\nsequenced"), 
#                                   size = 5, vjust = -1, hjust = -0.05, color = "black") +
#     # ggtitle(paste("Watchlist lineages (VoC) as of ", format(last(rolling_cases$date), "%b-%d-%Y"), #    sep="")) +
#     xlab("Login Date") +
#     ylab("Cumulative number of sequences") + scale_x_date(date_labels = "%b-%Y") +
#   scale_y_continuous(breaks = pretty_breaks())



```



<!-- ## VoI Sequence Numbers -->

```{r, results='asis', echo=FALSE, warning=FALSE, , include=F}
# max.counts.voi <- rolling.cases.voi %>% group_by(lin.fac) %>% filter(cumcases == max(cumcases))
# max.counts.voi <- subset(max.counts.voi, select = c(lineage, cumcases)) %>% arrange(-cumcases)
# colnames(max.counts.voi) <- c("Lineage", "Number of Genomes")
# # datatable(as.data.frame(max_counts_voi), extensions = 'Buttons',
# #           options = list(pageLength = 25, dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
# 
# 
# datatable(as.data.frame(max.counts.voi),
#           options = list(pageLength = 10, 
#                    columnDefs = list(list(className = 'dt-left', targets = '_all')),
#                                     # list(className = 'dt-center', targets = 4)),
#                    autowidth = TRUE,initComplete = JS(
#                             "function(settings, json) {",
#                             "$(this.api().table().header()).css({'color': 'white'});",
#                             "}"))) 

```
\



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=16, fig.height=10}
## VoI Sequence Distribution by Epidemiological Week

cols.voi <- c("#31B98F", "639B8B","#B7B7B7",  "#CF913C", "#819EE9", 
              "#741F39", "#D49998","#1F343C", "#C144BC", "red", "green",
              "black")

voi_groupings <- meta.df.recent[meta.df.recent$lineage.all %in% voi.list,] 

voi_groupings <- voi_groupings %>%
                    group_by(epi.wk.login, lineage.all) %>%
                    summarise(n = n()) %>%
                    mutate(rel.freq = 100*(n/sum(n))) %>%
                    arrange(desc(n))


plot_voi <- ggplot(voi_groupings, aes(x = epi.wk.login, y = n, fill = lineage.all)) +
  geom_bar(stat = "identity",) + 
  scale_fill_manual(values = cols.voi) +
  #, position="dodge"
    theme(panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank(),
                 panel.background = element_blank(),
                 plot.margin = unit(c(0,0,0,0), "cm"),
                axis.line = element_line(color="black"),
                legend.text=element_text(size=14),
                legend.title=element_text(size=16, face = "bold"),
                legend.position=c(0.94, 0.8),
                legend.box = "vertical",
                legend.box.margin = margin(0.05,0.05,0.05,0.05,"cm"),
                legend.box.background = element_rect(colour = "black"),
                legend.spacing.y = unit(0.1, "cm"),
                legend.key.width = unit(0.3, "cm"),
                legend.key.height = unit(0.3, "cm"),
                legend.spacing.x = unit(0.3, 'cm'),
                axis.text.x = element_text(angle = 0, size = 16),
                axis.text.y = element_text(size = 16),
                axis.title.x = element_text(angle = 0, size = 16, margin = margin(t = 20, r = 0, b = 0, l = 0)),
                axis.title.y = element_text(size = 16)) +
  #scale_fill_manual(values = cols.lin) +
  scale_y_continuous("Number of genomes") +
  coord_capped_cart(left='both', bottom = 'both') +
  labs(fill='Pango Lineage') + xlab("Epidemiological week")
  # scale_color_paletteer_d(awtools, a_palette)

```


```{r, warning=FALSE, fig.height=20, fig.width=14, echo=FALSE, message=FALSE, include=F}
plot_voi
```

***

# Mutation distributions

A table comprising the total counts and percentage of samples that have particular mutations can demonstrate the patterns of mutations across both VoC and non-VoC lineages. Characterization of these mutation patterns can assist in revealing the identity of mutations that may contribute to increased levels of clade and lineage transmission.\
\
Percentages include the percentage of all samples in the specific category (VoC or non-VoC) that have this mutation. Blank cells indicate that the mutation was not yet observed in the particular sample category (VoC or non-VoC) for samples sequenced at PHO. \
Information on the specific mutation profiles of Pango lineages can be found at:
[Outbreak.info](https://outbreak.info/)
\
\
```{r, include=F}
# placeholder
```
## Mutation frequencies for the Spike (S) protein

```{r, include=FALSE}
qc50_highest_voc <- meta.df.recent[meta.df.recent$lineage.all %in% c("B.1.1.7", "B.1.351", "P.1"),]

nextclade_qc50_voc <- nextclade_qc50[nextclade_qc50$seqName %in% qc50_highest_voc$WGS_Id,]

merged_voc_ontario <- merge(qc50_highest_voc, nextclade_qc50_voc, by.x = "WGS_Id",
                                by.y = "seqName")


separation <- unlist(strsplit(as.vector(merged_voc_ontario$aaSubstitutions),
                       split = ","))

all_muts_frame <- data.frame(table(separation))
all_muts_frame$percent_sample <- round(100*(all_muts_frame$Freq / nrow(merged_voc_ontario)), 2)
all_muts_frame$Gene <- str_split_fixed(all_muts_frame$separation, ":", 2)[,1]
colnames(all_muts_frame) <- c("Mutation", "Number of VoC Genomes", "Percent of VoC Genomes", "Gene")

all_muts_frame <- all_muts_frame %>% arrange(-`Percent of VoC Genomes`)

```

```{r, include=FALSE}
qc50_highest_non_voc <- meta.df.recent[! meta.df.recent$lineage.all %in% c("B.1.1.7", "B.1.351", "P.1", "None"),]

nextclade_qc50_non_voc <- nextclade_qc50[nextclade_qc50$seqName %in% qc50_highest_non_voc$WGS_Id,]

merged_non_voc_ontario <- merge(qc50_highest_non_voc, nextclade_qc50_non_voc, by.x = "WGS_Id",
                                by.y = "seqName", all.y = T)


separation <- unlist(strsplit(as.vector(merged_non_voc_ontario$aaSubstitutions),
                       split = ","))

all_muts_frame_no_voc <- data.frame(table(separation))
all_muts_frame_no_voc$percent_sample <- round(100*(all_muts_frame_no_voc$Freq / nrow(merged_non_voc_ontario)), 2)
all_muts_frame_no_voc$Gene <- str_split_fixed(all_muts_frame_no_voc$separation, ":", 2)[,1]
colnames(all_muts_frame_no_voc) <- c("Mutation", "Number of non-VoC Genomes", "Percent of non-VoC", "Gene")

all_muts_frame_no_voc <- all_muts_frame_no_voc %>% arrange(-`Percent of non-VoC`)

```

```{r, results='asis', echo=FALSE}
merge_mutations <- merge(all_muts_frame, all_muts_frame_no_voc, by.x = "Mutation",
                         by.y = "Mutation", all=T) %>% subset(select=c(-Gene.x)) %>% arrange(-`Percent of VoC Genomes`)
setnames(merge_mutations, "Gene.y", "Gene")
only_spike <- subset(merge_mutations, Gene == "S")
rownames(only_spike) <- NULL
# datatable(as.data.frame(only_spike), extensions = 'Buttons',
#           options = list(pageLength = 25, dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))

only_spike <- only_spike %>%
                dplyr::select(-Gene)

datatable(as.data.frame(only_spike), 
          options = list(pageLength = 10, 
                   columnDefs = list(list(className = 'dt-left', targets = 1:3),
                                     list(className = 'dt-center', targets = 4)),
                   autowidth = TRUE,initComplete = JS(
                            "function(settings, json) {",
                            "$(this.api().table().header()).css({'color': 'white'});",
                            "}"))) 

```

```{r, results='asis', echo=FALSE, include=F}
# datatable(as.data.frame(all_muts_frame_no_voc), extensions = 'Buttons',
#           options = list(pageLength = 25, dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))

datatable(as.data.frame(all_muts_frame_no_voc), 
          options = list(pageLength = 10, 
                   # columnDefs = list(list(className = 'dt-left', targets = 1:3),
                   #                   list(className = 'dt-center', targets = 4)),
                   autowidth = TRUE,initComplete = JS(
                            "function(settings, json) {",
                            "$(this.api().table().header()).css({'color': 'white'});",
                            "}"))) 

```
\
\
```{r, results='asis', echo=FALSE, include=F}
# datatable(as.data.frame(all_muts_frame), extensions = 'Buttons',
#           options = list(pageLength = 25, dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))

datatable(as.data.frame(all_muts_frame), 
          options = list(pageLength = 10, 
                   # columnDefs = list(list(className = 'dt-left', targets = 1:3),
                   #                   list(className = 'dt-center', targets = 4)),
                   autowidth = TRUE,initComplete = JS(
                            "function(settings, json) {",
                            "$(this.api().table().header()).css({'color': 'white'});",
                            "}"))) 
```

<!-- ## Pango lineage distribution among spike (S) protein mutations of concern for non-VoC/VoIs -->
<!-- \ -->
<!-- Tracking the distribution of lineages among the mutations of concern observed in the Spike protein S,  -->
<!-- which currently includes S:E484K and S:N501Y, allows for the identification of non-VoC and non-VoI lineages that carry mutations of concern. Spike mutations are correlated to increased transmissability and the potential for a vaccine escape mechanism when observed in conjunction with other mutations. Spike protein mutations S:E484K and S:N501Y have been observed both together and individually in Pango VoC and non-VoC lineages, so monitoring their frequency across all lineages will assist in tracking the phylogenetic power of these mutations.  -->

<!-- It is important to note that the Pango lineage identifier is dynamic, and is subject to change as the software and algorithm for lineage designation becomes more robust with a larger global dataset. As such, certain lineages designations for non-VoCs with S mutations may later be re-assigned to a VoC Pango lineage, and/or vice versa.  -->
<!-- \ -->
<!-- \ -->

<!-- ## Combined VoC and VoI Mutations -->
```{r, results='asis', echo=FALSE}
# # these are the combined VoC and VoI mutations
# lineages <- c("B.1.1.7", "B.1.351", "P.1", "P.2", "P.3", "B.1.525", "R.1", "B.1.1.318", "B.1.427", "B.1.429", "B.1.526", "B.1.526.1", "B.1.617", "B.1.617.1", "B.1.618", "B.1.617.2", "B.1.617.3")
# 
# non_voc_voi_counts <- mut_lin_date_grouped_final[! mut_lin_date_grouped_final$lineage %in% lineages,]
# 
# max_date_each_lin_non_voc <- non_voc_voi_counts %>% group_by(mutation, lineage) %>% filter(date == max(date))
# 
# table_mutations_non_voc <- subset(max_date_each_lin_non_voc, select = c(Mutation = mutation, Lineage = lineage, cumcases)) %>%
#   arrange(-cumcases) %>%
#  dplyr::select("Mutation" = "mutation", "Lineage" = "lineage", "Number of Genomes"= "cumcases")
# # datatable(as.data.frame(table_mutations_non_voc), extensions = 'Buttons',
# #           options = list(pageLength = 25, dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
# 
# 
# datatable(as.data.frame(table_mutations_non_voc), 
#           options = list(pageLength = 10, 
#                    # columnDefs = list(list(className = 'dt-left', targets = 1:3),
#                    #                   list(className = 'dt-center', targets = 4)),
#                    autowidth = TRUE,initComplete = JS(
#                             "function(settings, json) {",
#                             "$(this.api().table().header()).css({'color': 'white'});",
#                             "}"))) 

```
\
\
```{r, include=FALSE}

# subset_other_lineages <- subset(meta.df.recent, ! lineage.all %in% lineages) %>%
#   arrange(date) %>%
#   group_by(lineage.all, date) %>% 
#   summarise(counts = n())
# 
# rolling_cases_other <- subset_other_lineages %>% group_by(lineage.all, .drop = FALSE) %>%
#   mutate(cumcases = cumsum(counts), change = cumcases - lag(cumcases), days_between = date - lag(date))
# 
# rolling_cases_other$rate <- rolling_cases_other$change / as.numeric(rolling_cases_other$days_between)
# 
# rolling_cases_other$rate[is.na(rolling_cases_other$rate)] <- 0
# 
# highest_rates <- subset(rolling_cases_other, date > as.Date(Sys.Date() - 30)) %>% group_by(lineage.all) %>% filter(rate == max(rate)) %>%
#   arrange(desc(rate))
# 
# highest_rates_lineages <- highest_rates[1:12,]$lineage.all
# 
# rolling_avg <- rolling_cases_other %>% group_by(lineage.all) %>%
#   mutate(mean = (rate + lag(rate))/2)
# 
# highest_daily_ontario <- rolling_avg[rolling_avg$lineage.all %in% highest_rates_lineages,]
# 
# high_daily <- ggplot(highest_daily_ontario,
#        aes(x = date, y = rate)) + geom_line(col = "black") +
#   geom_smooth(method = "loess", span = 0.3, se = FALSE, col = "red", size = 0.5) +
#   facet_wrap(~lineage.all, ncol = 3) +
#   ylim(c(0, max(rolling_avg$rate + 15))) +
#   theme(axis.title.x = element_text(vjust=-0.5),
#         plot.margin = unit(c(0.25, 0.25, 0.25, 0.25), "cm"),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         panel.background = element_blank(), axis.line = element_line(colour = "black"),
#         panel.spacing.x = unit(15, "mm")) +
#   scale_x_date(date_labels = "%b-%Y") +
#   ggtitle("Greatest single-day rates of change, past month, non-VoC lineages") +
#   ggtitle(paste("Pango Lineages w/ highest daily rates, past month, non-VoC, as of ", format(Sys.Date(), "%b-%d-%Y"), sep="")) + xlab("Login Date") + ylab("Daily Case Number Increase")


```


```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width=10, fig.height=13.5, include=FALSE}
# high_daily
```

```{r, include=FALSE, echo=FALSE}
# overlap number in top 250 mutations for vocs and non vocs
# top_muts_voc <- as.vector(all_muts_frame$mutation[1:250])
# top_muts_non_voc <- as.vector(all_muts_frame_no_voc$mutation[1:250])
# length(intersect(top_muts_non_voc, top_muts_voc))

```

```{r, include=FALSE}
# trees_loc <- list.files("/home/mwatson/COVID-19/surveillance_reports/07-Apr-2021/", pattern = "iqtree.nwk", recursive = T)
# tree_paths <- paste("/home/mwatson/COVID-19/surveillance_reports/07-Apr-2021/", trees_loc,
#                     sep="")
# tree_paths
# ```
# ```{r, echo=FALSE, warning=FALSE, fig.height=13, fig.width=12, include=FALSE}
# for (i in tree_paths) {
#   tree <- read.tree(i)
#   tree <- drop.tip(tree, "MN908947")
# 
#   ## Create a data frame of the tree
#   tr.df <- fortify(tree)
#   ## Create a list of tree labels
#   tr.df.labs <- as.data.frame(tr.df) %>%
#   filter(isTip == "TRUE") %>%
#   select(label)
# 
#   # if the sample is not on the qc50 list, drop it from the tree
#   sample_no_pass <- as.data.frame(tr.df.labs[!tr.df.labs$label %in% meta.df.1$WGS_Id,])
#   colnames(sample_no_pass) <- "label"
#   tree <- drop.tip(tree, as.vector(sample_no_pass$label))
# 
#   ## Create a dataframe of the tree
#   tr.df <- fortify(tree)
#   ## Create a list of tree labels
#   tr.df.labs <- tr.df %>%
#     filter(isTip == "TRUE") %>%
#     select(label)
#   
#   date_cat <- interval(ymd(Sys.Date() - 7), ymd(Sys.Date()))
#   meta.df.1$date_cat <- ifelse(meta.df.1$date %within% date_cat, "Latest Week", "All Past Weeks")
#   qc50_keep <- subset(meta.df.1, select = c(WGS_Id, date, date_cat))
#   meta.df <- merge(tr.df.labs, qc50_keep, by.x = "label", by.y = "WGS_Id")
#   # treat the countries as a factor for plotting
#   meta.df$date_cat <- as.factor(meta.df$date_cat)
#   
#   
#   cols <- c("Latest Week" = "dark blue",  "All Past Weeks" = "grey60")
#   
#   meta.df$nml_lab <- paste("ON-PHL", str_split_fixed(meta.df$label, "PHLON|-SARS", 4)[,2],
#                          str_split_fixed(meta.df$label, "PHLON|-SARS", 4)[,3], sep = "-")
#   pl.1 <- ggtree(tree, size = 0.5)
#   pl.2 <- pl.1 %<+% meta.df +
#     geom_tippoint(aes(x=x+0.000001, subset=date_cat == "Latest Week", label = label, colour = date_cat),
#                   size = 2, shape = 16) +
#     geom_tippoint(aes(x=x+0.000001, subset=date_cat == "All Past Weeks", label = label, colour = date_cat),
#                   size = 2, shape = 16) +  
#   #geom_tiplab(aes(x=x+0.000001, subset=date_cat == "Latest Week", label = nml_lab),  size = 1.5, offset = 0.000005) +
#   # geom_tiplab(aes(x=x+0.000001, subset=label.2 == "non-PHO", label = label),  size = 1.5, offset = 0.000005) +
#     theme(plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
#         legend.text=element_text(size=12),
#         legend.position = c(0.85, 0.5),
#         plot.title = element_text(size = 20),
#         legend.title=element_text(size=15, face = "bold"),
#         legend.box = "vertical",
#         legend.box.margin = margin(0.01,0.02,0.02,0.02,"cm"),
#         legend.box.background = element_rect(colour = "grey50"),
#         legend.spacing.y = unit(0.1, "cm"),
#         legend.key.width = unit(0.3, "cm"),
#         legend.key.height = unit(0.3, "cm"),
#         legend.spacing.x = unit(0.3, 'cm'),
#         legend.key.size = unit(3,"lines")) +
#     scale_color_manual("Sequencing Period", values=cols) +
#     guides(color = guide_legend(override.aes = list(size = 1.75))) +
#     ggtitle(paste("Phylogenetic tree, ", str_split_fixed(i, "/", 8)[7], sep=""))
#   print(pl.2)
# }
```

\

***

# Nextstrain Phylogenetic tree URLS

Phylogenetic trees are generated through a statistical procedure that infers the ancestry and
similarity among sequences by considering their mutation profiles among with a model for mutation substitution rates. As such they represent the best possible relationship among a group of samples based on the mutation information available to the model. These relationships should not be considered as absolute, and are subject to biases related to sample quality and depth of sequencing coverage. 

Phylogenetic trees shown through [Nextstrain](https://nextstrain.publichealthontario.ca/ncov/) represent a subset of all samples sequenced at PHO that were selected based on genome completeness and overall high sequencing quality. Therefore the trees may not be reflective of the VoC sample numbers in the province at any specific point in time. 


[Nextstrain for PHO B.1.1.7 samples](https://nextstrain.publichealthontario.ca/ncov/?c=Pango.Lineage&f_Pango.Lineage=B.1.1.7&label=clade:20I/501Y.V1)
\

[Nextstrain for PHO B.1.351 samples](https://nextstrain.publichealthontario.ca/ncov/?c=Pango.Lineage&f_Pango.Lineage=B.1.351&label=clade:20H/501Y.V2)
\

[Nextstrain for PHO P.1 samples](https://nextstrain.publichealthontario.ca/ncov/?c=Pango.Lineage&f_Pango.Lineage=P.1&label=clade:20J/501Y.V3)
\
\

<br>

***

# References

1. Pango Lineages. https://cov-lineages.org/
2. Nextstrain. https://nextstrain.org/
3. Outbreak.info. https://outbreak.info/
\
\
```{r, include=FALSE}
#placeholder
```

<br>

***

# Technical Notes

## Pango lineage assignment categories
As of this date of reporting, Pango lineages are categorized based on the following assignment criteria: 
\
```{r, fig.height=12, fig.width=13, echo=FALSE}

VOC.df <- data.frame(voc.list)
VOI.df <- data.frame(voi.list) %>% arrange(voi.list)
  
voc.voi.list <- merge(VOI.df, VOC.df, by="row.names", all.x=TRUE)
voc.voi.list <-  voc.voi.list %>% 
                  select(VOC = voc.list, VOI = voi.list) %>% 
                  arrange(VOC, VOI) %>%
                  mutate(VOC = ifelse(!is.na(VOC), VOC, ""))
   

# kable(as.data.frame(voc.voi.list), caption = "Pango lineage designation guide",
#       align=rep('l', 5))

datatable(as.data.frame(voc.voi.list), 
          options = list(pageLength = 20, 
                   # columnDefs = list(list(className = 'dt-left', targets = 1:3),
                   #                   list(className = 'dt-center', targets = 4)),
                   autowidth = TRUE,initComplete = JS(
                            "function(settings, json) {",
                            "$(this.api().table().header()).css({'color': 'white'});",
                            "}"))) 


```

## Mutation Combinations {.tabset}

### VoCs

```{r, include=F, echo=F, message=F}

mut_combos <- data.frame(mut = character(), pair = character(),
                         freq = numeric())

muts_to_eval <- c("S:N501Y", "S:E484K", "S:E484Q", "S:K417N", "S:K417T")

for (spike in muts_to_eval) {
  only_mut <- merged_voc_ontario[grepl(spike, merged_voc_ontario$aaSubstitutions),]
  mutations_accompany <- unique(unlist(strsplit(as.vector(only_mut$aaSubstitutions),
                                                split = ",")))
  for (i in mutations_accompany) {
    with_mut <- only_mut[grepl(i, only_mut$aaSubstitutions),]
    percentage <- 100*(nrow(with_mut)/nrow(only_mut))
    if (grepl("S:", i) && !is.na(i) && percentage >= 1) {
      to_add <- data.frame(mut = spike, pair = i, freq = percentage)
      mut_combos <- rbind(mut_combos, to_add)
    }
  }
}


order_of_muts <- subset(mut_combos) %>% arrange(mut, -freq)
order_of_muts <- order_of_muts$pair

mut_combos$pair <- factor(mut_combos$pair, levels = unique(order_of_muts))

mut_combos <- mut_combos[!is.na(mut_combos$pair),]
```


```{r, echo=F, warning=F, message=F, fig.height=8, fig.width=10}
library(heatmaply)

spread_muts <- mut_combos %>% spread(pair, freq)

for_heatmap <- spread_muts[,-1]
row.names(for_heatmap) <- spread_muts$mut
for_heatmap[is.na(for_heatmap)] <- 0

gradient_heatmaply <- ggplot2::scale_fill_gradient2(
  low = "white", high = "blue")

heatmaply(for_heatmap, xlab = "Paired Spike mutation", ylab = "Focal Spike Mutation",
          label_names = c("VoC samples with", "that also have", "Combination percentage"),
          scale_fill_gradient_fun = gradient_heatmaply) 
```

### non-VOCs
```{r, include=F, echo=F, message=F}
mut_combos_non <- data.frame(mut = character(), pair = character(),
                         freq = numeric())

muts_to_eval <- c("S:N501Y", "S:E484K", "S:E484Q", "S:K417N", "S:K417T")

for (spike in muts_to_eval) {
  only_mut_non <- merged_non_voc_ontario[grepl(spike, merged_non_voc_ontario$aaSubstitutions),]
  mutations_accompany <- unique(unlist(strsplit(as.vector(only_mut_non$aaSubstitutions),
                                                split = ",")))
  for (i in mutations_accompany) {
    with_mut_non <- only_mut_non[grepl(i, only_mut_non$aaSubstitutions),]
    percentage <- 100*(nrow(with_mut_non)/nrow(only_mut_non))
    if (grepl("S:", i) && !is.na(i) && percentage >= 1) {
      to_add <- data.frame(mut = spike, pair = i, freq = percentage)
      mut_combos_non <- rbind(mut_combos_non, to_add)
    }
  }
}


order_of_muts_non <- mut_combos_non %>% arrange(mut, -freq)
order_of_muts_non <- order_of_muts_non$pair

mut_combos_non$pair <- factor(mut_combos_non$pair, levels = unique(order_of_muts_non))

mut_combos_non <- mut_combos_non[!is.na(mut_combos_non$pair),]
```

```{r, echo=F, warning=F, message=F, fig.height=8, fig.width=10}
library(heatmaply)

spread_muts_non <- mut_combos_non %>% spread(pair, freq)

for_heatmap_non <- spread_muts_non[,-1]
row.names(for_heatmap_non) <- spread_muts_non$mut
for_heatmap_non[is.na(for_heatmap_non)] <- 0

gradient_heatmaply <- ggplot2::scale_fill_gradient2(
  low = "white", high = "blue")

heatmaply(for_heatmap_non, xlab = "Paired Spike mutation", ylab = "Focal Spike Mutation",
          label_names = c("non-VoC samples with", "that also have", "Combination percentage"),
          scale_fill_gradient_fun = gradient_heatmaply)
```

 
 
 